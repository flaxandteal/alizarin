{"version":3,"file":"alizarin.umd.cjs","sources":["../src/utils.ts","../src/static-types.ts","../src/client.ts","../src/rdm.ts","../src/staticStore.ts","../src/nodeConfig.ts","../src/viewModels.ts","../src/pseudos.ts","../src/graphManager.ts","../src/renderers.ts","../src/main.ts","../__vite-browser-external"],"sourcesContent":["import { IStringKeyedObject } from \"./interfaces\";\n\n// TODO: make this customizable.\nconst DEFAULT_LANGUAGE = \"en\";\n\nfunction getCurrentLanguage(): string {\n  return ((typeof navigator != 'undefined' && navigator.language) || DEFAULT_LANGUAGE).slice(0, 2);\n}\n\nclass AttrPromise<T> extends Promise<T> implements IStringKeyedObject {\n  [Symbol.toPrimitive]: undefined;\n  constructor(\n    executor: (\n      resolve: (value: T | PromiseLike<T>) => void,\n      reject: (reason: any) => void,\n    ) => void,\n  ) {\n    super(executor);\n    return new Proxy(this, {\n      set: (object: IStringKeyedObject, keyObj, value) => {\n        if (object instanceof Promise) {\n          return object.then((val) => {\n            val[keyObj] = value;\n            return val;\n          });\n        }\n        object[keyObj] = value;\n        return this;\n      },\n      get: (object: IStringKeyedObject, keyObj) => {\n        if (keyObj in object) {\n          if (typeof object[keyObj] === \"function\") {\n            return object[keyObj].bind(object);\n          }\n          return object[keyObj];\n        }\n        const key = keyObj.toString();\n        if (key in object) {\n          if (typeof object[key] === \"function\") {\n            return object[key].bind(object);\n          }\n          return object[key];\n        }\n        if (object instanceof Promise) {\n          return object.then((val) => {\n            return val ? val[keyObj] : val;\n          });\n        }\n        return object[keyObj];\n      },\n    });\n  }\n}\n\nexport { AttrPromise, getCurrentLanguage };\n","import { getCurrentLanguage } from './utils';\n\nclass StaticGraphMeta {\n  [key: string]: any\n  author: string | undefined\n  cards: number | undefined\n  cards_x_nodes_x_widgets: number | undefined\n  color: string | undefined\n  description: {[lang: string]: string} | undefined\n  edges: number | undefined\n  graphid: string\n  iconclass: string | undefined\n  is_editable: boolean | undefined\n  isresource: boolean | undefined\n  jsonldcontext: {[key: string]: any} | undefined\n  name: {[lang: string]: string} | undefined\n  nodegroups: number | undefined\n  nodes: number | undefined\n  ontology_id: string | undefined\n  publication: {[key: string]: string | null} | undefined\n  relatable_resource_model_ids: string[] = []\n  resource_2_resource_constraints: any[] = []\n  root: StaticNode | undefined\n  slug: string | undefined\n  subtitle: {[lang: string]: string} | undefined\n  version: string | undefined\n\n  constructor(jsondata: StaticGraphMeta) {\n    this.graphid = jsondata.graphid;\n    Object.assign(this, jsondata)\n  }\n}\n\nclass StaticTranslatableString extends String {\n  translations: Map<string, string>;\n  lang: string;\n\n  constructor(\n    s: string | StaticTranslatableString,\n    lang: undefined | string = undefined,\n  ) {\n    let translations: Map<string, string>;\n    let finalLang: string;\n    if (s instanceof StaticTranslatableString) {\n      translations = new Map(s.translations);\n      if (lang === undefined) {\n        finalLang = s.lang;\n      } else {\n        finalLang = lang;\n      }\n    } else if (typeof s === \"object\") {\n      translations = new Map(Object.entries(s));\n      if (lang === undefined || !translations.has(lang)) {\n        const defaultLanguage = getCurrentLanguage();\n        if (!translations || translations.has(defaultLanguage)) {\n          finalLang = defaultLanguage;\n        } else {\n          finalLang = Object.keys(s)[0];\n        }\n      } else {\n        finalLang = lang;\n      }\n    } else {\n      translations = new Map();\n      finalLang = lang || getCurrentLanguage();\n      translations.set(finalLang, s);\n    }\n    s = translations.get(finalLang) || \"\";\n    super(s);\n    this.translations = translations;\n    this.lang = finalLang;\n  }\n}\n\nclass StaticNodegroup {\n  legacygroupid: null;\n  nodegroupid: string;\n  parentnodegroup_id: string | null;\n  cardinality: \"1\" | \"n\" | null;\n\n  constructor(jsonData: StaticNodegroup) {\n    this.legacygroupid = jsonData.legacygroupid;\n    this.nodegroupid = jsonData.nodegroupid;\n    this.parentnodegroup_id = jsonData.parentnodegroup_id;\n    this.cardinality = jsonData.cardinality;\n  }\n}\n\nclass StaticNode {\n  alias: string | null;\n  config: { [key: string]: any };\n  datatype: string;\n  description: string | null;\n  exportable: boolean;\n  fieldname: null | string;\n  graph_id: string;\n  hascustomalias: boolean;\n  is_collector: boolean;\n  isrequired: boolean;\n  issearchable: boolean;\n  istopnode: boolean;\n  name: string;\n  nodegroup_id: string | null;\n  nodeid: string;\n  parentproperty: string | null = null;\n  sortorder: number;\n  ontologyclass: string | null = null;\n  sourcebranchpublication_id: null | string = null;\n\n  constructor(jsonData: StaticNode) {\n    this.alias = jsonData.alias;\n    this.config = jsonData.config;\n    this.datatype = jsonData.datatype;\n    this.description = jsonData.description;\n    this.exportable = jsonData.exportable;\n    this.fieldname = jsonData.fieldname;\n    this.graph_id = jsonData.graph_id;\n    this.hascustomalias = jsonData.hascustomalias;\n    this.is_collector = jsonData.is_collector;\n    this.isrequired = jsonData.isrequired;\n    this.issearchable = jsonData.issearchable;\n    this.istopnode = jsonData.istopnode;\n    this.name = jsonData.name;\n    this.nodegroup_id = jsonData.nodegroup_id;\n    this.nodeid = jsonData.nodeid;\n    this.parentproperty = jsonData.parentproperty;\n    this.sortorder = jsonData.sortorder;\n    this.ontologyclass = jsonData.ontologyclass;\n    this.sourcebranchpublication_id = jsonData.sourcebranchpublication_id;\n  }\n}\n\nclass StaticConstraint {\n  card_id: string;\n  constraintid: string;\n  nodes: Array<string>;\n  uniquetoallinstances: boolean;\n\n  constructor(jsonData: StaticConstraint) {\n    this.card_id = jsonData.card_id;\n    this.constraintid = jsonData.constraintid;\n    this.nodes = jsonData.nodes;\n    this.uniquetoallinstances = jsonData.uniquetoallinstances;\n  }\n}\n\nclass StaticCard {\n  active: boolean;\n  cardid: string;\n  component_id: string;\n  config: null | object;\n  constraints: Array<StaticConstraint>;\n  cssclass: null | string;\n  description: string | null | StaticTranslatableString;\n  graph_id: string;\n  helpenabled: boolean;\n  helptext: StaticTranslatableString;\n  helptitle: StaticTranslatableString;\n  instructions: StaticTranslatableString;\n  is_editable: boolean;\n  name: StaticTranslatableString;\n  nodegroup_id: string;\n  sortorder: number | null;\n  visible: boolean;\n\n  constructor(jsonData: StaticCard) {\n    this.active = jsonData.active;\n    this.cardid = jsonData.cardid;\n    this.component_id = jsonData.component_id;\n    this.config = jsonData.config;\n    this.constraints = jsonData.constraints.map(\n      (constraint) => new StaticConstraint(constraint),\n    );\n    this.cssclass = jsonData.cssclass;\n    this.description =\n      jsonData.description &&\n      new StaticTranslatableString(jsonData.description);\n    this.graph_id = jsonData.graph_id;\n    this.helpenabled = jsonData.helpenabled;\n    this.helptext = new StaticTranslatableString(jsonData.helptext);\n    this.helptitle = new StaticTranslatableString(jsonData.helptitle);\n    this.instructions = new StaticTranslatableString(jsonData.instructions);\n    this.is_editable = jsonData.is_editable;\n    this.name = new StaticTranslatableString(jsonData.name);\n    this.nodegroup_id = jsonData.nodegroup_id;\n    this.sortorder = jsonData.sortorder;\n    this.visible = jsonData.visible;\n  }\n}\n\nclass StaticCardsXNodesXWidgets {\n  card_id: string;\n  config: object;\n  id: string;\n  label: StaticTranslatableString;\n  node_id: string;\n  sortorder: number;\n  visible: boolean;\n  widget_id: string;\n\n  constructor(jsonData: StaticCardsXNodesXWidgets) {\n    this.card_id = jsonData.card_id;\n    this.config = jsonData.config;\n    this.id = jsonData.id;\n    this.label = new StaticTranslatableString(jsonData.label);\n    this.node_id = jsonData.node_id;\n    this.sortorder = jsonData.sortorder;\n    this.visible = jsonData.visible;\n    this.widget_id = jsonData.widget_id;\n  }\n}\n\nclass StaticEdge {\n  description: null;\n  domainnode_id: string;\n  edgeid: string;\n  graph_id: string;\n  name: null | string;\n  rangenode_id: string;\n  ontologyproperty: null | string = null;\n\n  constructor(jsonData: StaticEdge) {\n    this.description = jsonData.description;\n    this.domainnode_id = jsonData.domainnode_id;\n    this.edgeid = jsonData.edgeid;\n    this.graph_id = jsonData.graph_id;\n    this.name = jsonData.name;\n    this.rangenode_id = jsonData.rangenode_id;\n    this.ontologyproperty = jsonData.ontologyproperty;\n  }\n}\n\nclass StaticFunctionsXGraphs {\n  config: object;\n  function_id: string;\n  graph_id: string;\n  id: string;\n\n  constructor(jsonData: StaticFunctionsXGraphs) {\n    this.config = jsonData.config;\n    this.function_id = jsonData.function_id;\n    this.graph_id = jsonData.graph_id;\n    this.id = jsonData.id;\n  }\n}\n\nclass StaticPublication {\n  graph_id: string;\n  notes: null | string;\n  publicationid: string;\n  published_time: string;\n\n  constructor(jsonData: StaticPublication) {\n    this.graph_id = jsonData.graph_id;\n    this.notes = jsonData.notes;\n    this.publicationid = jsonData.publicationid;\n    this.published_time = jsonData.published_time;\n  }\n}\n\nclass StaticGraph {\n  author: string;\n  cards: Array<StaticCard> | null = null;\n  cards_x_nodes_x_widgets: Array<StaticCardsXNodesXWidgets> | null = null;\n  color: string | null;\n  config: object;\n  deploymentdate: null | string;\n  deploymentfile: null | string;\n  description: StaticTranslatableString;\n  edges: Array<StaticEdge>;\n  functions_x_graphs: Array<StaticFunctionsXGraphs> | null = null;\n  graphid: string;\n  iconclass: string;\n  is_editable: boolean | null = null;\n  isresource: boolean;\n  jsonldcontext: string | null;\n  name: StaticTranslatableString;\n  nodegroups: Array<StaticNodegroup>;\n  nodes: Array<StaticNode>;\n  ontology_id: string | null;\n  publication: StaticPublication | null = null;\n  relatable_resource_model_ids: Array<string>;\n  resource_2_resource_constraints: Array<any> | null = null;\n  root: StaticNode;\n  slug: string | null;\n  subtitle: StaticTranslatableString;\n  template_id: string;\n  version: string;\n\n  constructor(jsonData: StaticGraph) {\n    this.author = jsonData.author;\n    this.cards =\n      jsonData.cards && jsonData.cards.map((card) => new StaticCard(card));\n    this.cards_x_nodes_x_widgets =\n      jsonData.cards_x_nodes_x_widgets &&\n      jsonData.cards_x_nodes_x_widgets.map(\n        (card_x_node_x_widget) =>\n          new StaticCardsXNodesXWidgets(card_x_node_x_widget),\n      );\n    this.color = jsonData.color;\n    this.config = jsonData.config;\n    this.deploymentdate = jsonData.deploymentdate;\n    this.deploymentfile = jsonData.deploymentfile;\n    this.description = new StaticTranslatableString(jsonData.description);\n    this.edges = jsonData.edges.map((edge) => new StaticEdge(edge));\n    this.functions_x_graphs =\n      jsonData.functions_x_graphs &&\n      jsonData.functions_x_graphs.map(\n        (functions_x_graphs) => new StaticFunctionsXGraphs(functions_x_graphs),\n      );\n    this.graphid = jsonData.graphid;\n    this.iconclass = jsonData.iconclass;\n    this.is_editable = jsonData.is_editable;\n    this.isresource = jsonData.isresource;\n    this.jsonldcontext = jsonData.jsonldcontext;\n    this.name = new StaticTranslatableString(jsonData.name);\n    this.nodegroups = jsonData.nodegroups.map(\n      (nodegroup) => new StaticNodegroup(nodegroup),\n    );\n    this.nodes = jsonData.nodes.map((node) => new StaticNode(node));\n    this.ontology_id = jsonData.ontology_id;\n    this.publication =\n      jsonData.publication && new StaticPublication(jsonData.publication);\n    this.relatable_resource_model_ids = jsonData.relatable_resource_model_ids;\n    this.resource_2_resource_constraints =\n      jsonData.resource_2_resource_constraints;\n    this.root = jsonData.root;\n    this.slug = jsonData.slug;\n    this.subtitle = new StaticTranslatableString(jsonData.subtitle);\n    this.template_id = jsonData.template_id;\n    this.version = jsonData.version;\n  }\n}\n\n/// Resources\n//\ntype StaticProvisionalEdit = any;\n\nclass StaticValue {\n  id: string;\n  value: string;\n  __concept: StaticConcept | null;\n  __conceptId: string | null;\n\n  constructor(jsonData: StaticValue, concept: StaticConcept | string | null = null) {\n    this.id = jsonData.id;\n    this.value = jsonData.value;\n    if (concept instanceof StaticConcept) {\n      this.__concept = concept;\n      this.__conceptId = concept ? concept.id : null;\n    } else {\n      this.__concept = null;\n      this.__conceptId = concept;\n    }\n  }\n\n  toString() {\n    return this.value;\n  }\n}\n\nclass StaticConcept {\n  id: string;\n  prefLabels: { [lang: string]: StaticValue };\n  source: string | null;\n  sortOrder: number | null;\n  children: StaticConcept[] | null;\n\n  constructor(jsonData: StaticConcept) {\n    this.id = jsonData.id;\n    this.prefLabels = jsonData.prefLabels;\n    for (const [lang, value] of Object.entries(this.prefLabels)) {\n      if (!(value instanceof StaticValue)) {\n        this.prefLabels[lang] = new StaticValue(value, this);\n      }\n    }\n    this.source = jsonData.source;\n    this.sortOrder = jsonData.sortOrder;\n    this.children = jsonData.children;\n    if (this.children) {\n      this.children = this.children.map((child) => {\n        return child instanceof StaticConcept\n          ? child\n          : new StaticConcept(child);\n      });\n    }\n  }\n\n  getPrefLabel(): StaticValue {\n    return (\n      this.prefLabels[getCurrentLanguage()] || Object.values(this.prefLabels)[0]\n    );\n  }\n\n  toString() {\n    return this.getPrefLabel().value;\n  }\n}\n\n// A prefLabel, for example, can only exist once per language.\nclass StaticCollection {\n  id: string;\n  prefLabels: { [lang: string]: StaticValue };\n  concepts: { [conceptId: string]: StaticConcept };\n  __allConcepts: { [conceptId: string]: StaticConcept };\n  __values: { [valueId: string]: StaticValue };\n\n  constructor(jsonData: StaticCollection) {\n    this.id = jsonData.id;\n    this.prefLabels = jsonData.prefLabels;\n    this.concepts = jsonData.concepts;\n    this.__allConcepts = {};\n    this.__values = {};\n    const addValues = (concept: StaticConcept) => {\n      this.__allConcepts[concept.id] = concept;\n      for (const [_, value] of Object.entries(concept.prefLabels)) {\n        this.__values[value.id] = value;\n      }\n      if (concept.children) {\n        for (let child of concept.children) {\n          if (!(child instanceof StaticConcept)) {\n            child = new StaticConcept(child);\n          }\n          addValues(child);\n        }\n      }\n    };\n    for (const [id, concept] of Object.entries(this.concepts)) {\n      if (!(concept instanceof StaticConcept)) {\n        this.concepts[id] = new StaticConcept(concept);\n      }\n      addValues(this.concepts[id]);\n    }\n  }\n\n  getConceptValue(valueId: string) {\n    return this.__values[valueId];\n  }\n\n  toString() {\n    return this.prefLabels[getCurrentLanguage()] || Object.values(this.prefLabels)[0];\n  }\n}\n\nclass StaticTile {\n  data: Map<\n    string,\n    object | Map<string, any> | Array<any> | null | number | boolean | string\n  >;\n  nodegroup_id: string;\n  resourceinstance_id: string;\n  tileid: string | null;\n  parenttile_id: string | null = null;\n  provisionaledits: null | Array<StaticProvisionalEdit> = null;\n  sortorder: number | null = null;\n\n  constructor(jsonData: StaticTile) {\n    this.data = jsonData.data;\n    if (typeof this.data === 'object' && !(this.data instanceof Map)) {\n      this.data = new Map(Object.entries(this.data));\n    }\n    this.nodegroup_id = jsonData.nodegroup_id;\n    this.resourceinstance_id = jsonData.resourceinstance_id;\n    this.tileid = jsonData.tileid;\n    this.parenttile_id = jsonData.parenttile_id;\n    this.provisionaledits = jsonData.provisionaledits;\n    this.sortorder = jsonData.sortorder;\n  }\n\n  ensureId(): string {\n    if (!this.tileid) {\n      this.tileid = crypto.randomUUID();\n    }\n    return this.tileid;\n  }\n}\n\nclass StaticResourceDescriptors {\n  [key: string]: (string | undefined | Function);\n  name?: string;\n  map_popup?: string;\n  description?: string;\n\n  constructor(jsonData?: StaticResourceDescriptors) {\n    if (jsonData) {\n      this.name = jsonData.name;\n      this.map_popup = jsonData.map_popup;\n      this.description = jsonData.description;\n    }\n  }\n\n  isEmpty(): boolean {\n    return !(this.name || this.map_popup || this.description);\n  }\n}\n\nclass StaticResourceMetadata {\n  descriptors: StaticResourceDescriptors;\n  graph_id: string;\n  name: string;\n  resourceinstanceid: string;\n  publication_id: string | null = null;\n  principaluser_id: number | null = null;\n  legacyid: null | string = null;\n  graph_publication_id: string | null = null;\n\n  constructor(jsonData: StaticResourceMetadata) {\n    this.descriptors = jsonData.descriptors;\n    if (!(this.descriptors instanceof StaticResourceDescriptors)) {\n      if (jsonData.descriptors instanceof Map) {\n        this.descriptors = new StaticResourceDescriptors(Object.fromEntries(jsonData.descriptors.entries()));\n      } else {\n        this.descriptors = new StaticResourceDescriptors(this.descriptors);\n      }\n    }\n    this.graph_id = jsonData.graph_id;\n    this.name = jsonData.name;\n    this.resourceinstanceid = jsonData.resourceinstanceid;\n    this.publication_id = jsonData.publication_id;\n    this.principaluser_id = jsonData.principaluser_id;\n    this.legacyid = jsonData.legacyid;\n    this.graph_publication_id = jsonData.graph_publication_id;\n  }\n}\n\nclass StaticDomainValue {\n  id: string\n  selected: boolean\n  text: {[lang: string]: string}\n\n  constructor(jsonData: StaticDomainValue) {\n    this.id = jsonData.id;\n    this.selected = jsonData.selected;\n    this.text = jsonData.text;\n  }\n\n  toString() {\n    const lang = getCurrentLanguage();\n    let localized = this.text[lang];\n    if (typeof localized !== \"string\") {\n      localized = Object.values(this.text)[0];\n    }\n    if (!localized) {\n      throw Error(`Could not render domain value ${this.id} in language ${lang}`);\n    }\n    return localized;\n  }\n\n  lang(lang: string): string | undefined {\n    return this.text[lang];\n  }\n\n  async forJson() {\n    return {\n      id: this.id,\n      selected: this.selected,\n      text: this.text\n    }\n  }\n}\n\nclass StaticResourceReference {\n  id: string;\n  type: string | undefined;\n  graphId: string;\n  title: string | undefined;\n  root: any | undefined;\n  meta?: {[key: string]: any};\n\n  constructor(jsonData: StaticResourceReference) {\n    this.id = jsonData.id;\n    this.type = jsonData.type;\n    this.graphId = jsonData.graphId;\n    this.root = jsonData.root;\n    this.title = jsonData.title;\n    if (jsonData.meta) {\n      this.meta = jsonData.meta;\n    }\n  }\n}\n\nclass StaticResource {\n  resourceinstance: StaticResourceMetadata;\n  tiles: Array<StaticTile> | null = null;\n  metadata: {[key: string]: string};\n  __cache: {[tileId: string]: {[nodeId: string]: {[key: string]: string}}} | undefined = undefined;\n  __source: string | undefined = undefined;\n  __scopes: string[] | undefined = undefined;\n\n  constructor(jsonData: StaticResource) {\n    this.resourceinstance = new StaticResourceMetadata(\n      jsonData.resourceinstance,\n    );\n    this.tiles =\n      jsonData.tiles && jsonData.tiles.map((tile) => new StaticTile(tile));\n    this.metadata = jsonData.metadata || {};\n    this.__cache = jsonData.__cache;\n    this.__scopes = jsonData.__scopes;\n  }\n}\n\nexport {\n  StaticValue,\n  StaticTile,\n  StaticGraph,\n  StaticResource,\n  StaticResourceMetadata,\n  StaticNode,\n  StaticNodegroup,\n  StaticEdge,\n  StaticCard,\n  StaticCardsXNodesXWidgets,\n  StaticCollection,\n  StaticConcept,\n  StaticDomainValue,\n  StaticResourceReference,\n  StaticGraphMeta,\n  StaticFunctionsXGraphs,\n  StaticResourceDescriptors\n};\n","import * as bfj from \"bfj\";\nimport * as check from 'check-types';\nimport { StaticGraphMeta, StaticGraph, StaticResource } from \"./static-types\";\nimport { StaticCollection } from \"./rdm\";\nimport { IStringKeyedObject } from \"./interfaces\";\n\nclass GraphResult {\n  models: {[graphId: string]: StaticGraphMeta};\n\n  constructor(jsonData: GraphResult) {\n    this.models = Object.fromEntries(\n      Object.entries(jsonData.models).map(([k, v]) => [k, new StaticGraphMeta(v)])\n    );\n  }\n}\n\nabstract class ArchesClient {\n  abstract getGraphs(): Promise<GraphResult>;\n\n  abstract getGraph(graph: StaticGraphMeta): Promise<StaticGraph | null>;\n\n  abstract getGraphByIdOnly(graphId: string): Promise<StaticGraph | null>;\n\n  abstract getResources(\n    graphId: string,\n    limit: number,\n  ): Promise<StaticResource[]>;\n\n  abstract getResource(resourceId: string): Promise<StaticResource>;\n\n  abstract getCollection(collectionId: string): Promise<StaticCollection>;\n}\n\nclass ArchesClientRemote extends ArchesClient {\n  archesUrl: string;\n\n  constructor(archesUrl: string) {\n    super();\n    this.archesUrl = archesUrl;\n  }\n\n  async getGraphs(): Promise<GraphResult> {\n    const response = await fetch(\n      `${this.archesUrl}/api/arches/graphs?format=arches-json&hide_empty_nodes=false&compact=false`,\n    );\n    return await response.json();\n  }\n\n  async getGraph(graph: StaticGraphMeta): Promise<StaticGraph> {\n    return this.getGraphByIdOnly(graph.graphid);\n  }\n\n  async getGraphByIdOnly(graphId: string): Promise<StaticGraph> {\n    const response = await fetch(\n      `${this.archesUrl}/graphs/${graphId}?format=arches-json&gen=`,\n    );\n    return await response.json();\n  }\n\n  async getResource(resourceId: string): Promise<StaticResource> {\n    throw Error(`Not implemented yet: getResource(${resourceId}`);\n  }\n\n  async getCollection(collectionId: string): Promise<StaticCollection> {\n    throw Error(`Not implemented yet: getCollection(${collectionId}`);\n  }\n\n  async getResources(\n    graphId: string,\n    limit: number,\n  ): Promise<StaticResource[]> {\n    const response = await fetch(\n      `${this.archesUrl}/resources?graph_uuid=${graphId}&format=arches-json&hide_empty_nodes=false&compact=false&limit=${limit}`,\n    );\n    return await response.json();\n  }\n}\n\nclass ArchesClientRemoteStatic extends ArchesClient {\n  archesUrl: string;\n  allGraphFile: Function;\n  graphToGraphFile: Function;\n  graphIdToGraphFile: Function;\n  graphIdToResourcesFiles: Function;\n  resourceIdToFile: Function;\n  collectionIdToFile: Function;\n\n  constructor(\n    archesUrl: string,\n    {\n      allGraphFile,\n      graphToGraphFile,\n      graphIdToResourcesFiles,\n      resourceIdToFile,\n      collectionIdToFile,\n      graphIdToGraphFile,\n    }: { [k: string]: Function } = {},\n  ) {\n    super();\n    this.archesUrl = archesUrl;\n    this.allGraphFile = allGraphFile || (() => \"resource_models/_all.json\");\n    this.graphToGraphFile = graphToGraphFile;\n    this.graphIdToGraphFile =\n      graphIdToGraphFile ||\n      ((graphId: string) => `resource_models/${graphId}.json`);\n    this.graphIdToResourcesFiles =\n      graphIdToResourcesFiles ||\n      ((graphId: string) => [`business_data/_${graphId}.json`]);\n    this.resourceIdToFile =\n      resourceIdToFile ||\n      ((resourceId: string) => `business_data/${resourceId}.json`);\n    this.collectionIdToFile =\n      collectionIdToFile ||\n      ((collectionId: string) => `collections/${collectionId}.json`);\n  }\n\n  async getGraphs(): Promise<GraphResult> {\n    const response = await fetch(`${this.archesUrl}/${this.allGraphFile()}`);\n    return await response.json();\n  }\n\n  async getGraph(graph: StaticGraphMeta): Promise<StaticGraph | null> {\n    if (!this.graphToGraphFile) {\n      return this.getGraphByIdOnly(graph.graphid);\n    }\n    const response = await fetch(\n      `${this.archesUrl}/${this.graphToGraphFile(graph)}`,\n    );\n    return (await response.json()).graph[0];\n  }\n\n  async getGraphByIdOnly(graphId: string): Promise<StaticGraph | null> {\n    const response = await fetch(\n      `${this.archesUrl}/${this.graphIdToGraphFile(graphId)}`,\n    );\n    return (await response.json()).graph[0];\n  }\n\n  async getResource(resourceId: string): Promise<StaticResource> {\n    const source = `${this.archesUrl}/${this.resourceIdToFile(resourceId)}`;\n    const response = await fetch(source);\n    return response.json().then((response: StaticResource) => {\n      response.__source = source;\n      return response;\n    });\n  }\n\n  async getCollection(collectionId: string): Promise<StaticCollection> {\n    const response = await fetch(\n      `${this.archesUrl}/${this.collectionIdToFile(collectionId)}`,\n    );\n    return await response.json();\n  }\n\n  async getResources(\n    graphId: string,\n    limit: number,\n  ): Promise<StaticResource[]> {\n    const resources = [];\n    for (const file of this.graphIdToResourcesFiles(graphId)) {\n      const source = `${this.archesUrl}/${file}`;\n      const response = await fetch(source);\n      const resourceSet: StaticResource[] = (await response.json()).business_data.resources;\n      for (const resource of resourceSet) {\n        resource.__source = source;\n      }\n      resources.push(...(limit ? resourceSet.slice(0, limit) : resourceSet));\n      if (limit && resources.length > limit) {\n        break;\n      }\n    }\n    return resources;\n  }\n}\n\nclass ArchesClientLocal extends ArchesClient {\n  fs: any;\n  allGraphFile: Function;\n  graphToGraphFile: Function;\n  graphIdToGraphFile: Function;\n  graphIdToResourcesFiles: Function;\n  resourceIdToFile: Function;\n  collectionIdToFile: Function;\n\n  constructor({\n    allGraphFile,\n    graphToGraphFile,\n    graphIdToResourcesFiles,\n    resourceIdToFile,\n    collectionIdToFile,\n    graphIdToGraphFile,\n  }: { [k: string]: Function } = {}) {\n    super();\n    this.fs = import(\"fs\");\n    this.allGraphFile = allGraphFile || (() => \"tests/definitions/models/_all.json\");\n    this.graphToGraphFile =\n      graphToGraphFile ||\n      ((graph: StaticGraph) => `tests/definitions/models/${graph.graphid}.json`);\n    this.graphIdToGraphFile =\n      graphIdToGraphFile ||\n      ((graphId: string) => `tests/definitions/models/${graphId}.json`);\n    this.graphIdToResourcesFiles =\n      graphIdToResourcesFiles ||\n      ((graphId: string) => [`tests/definitions/resources/_${graphId}.json`]);\n    this.resourceIdToFile =\n      resourceIdToFile ||\n      ((resourceId: string) => `tests/definitions/resources/${resourceId}.json`);\n    this.collectionIdToFile =\n      collectionIdToFile ||\n      ((collectionId: string) => `tests/definitions/collections/${collectionId}.json`);\n  }\n\n  async getGraphs(): Promise<GraphResult> {\n    const fs = await this.fs;\n    const response = await fs.promises.readFile(this.allGraphFile(), \"utf8\");\n    return new GraphResult(await JSON.parse(response));\n  }\n\n  async getGraph(graph: StaticGraphMeta): Promise<StaticGraph | null> {\n    const fs = await this.fs;\n    const graphFile = this.graphToGraphFile ? this.graphToGraphFile(graph) : this.graphIdToGraphFile(graph.graphid);\n    if (!graphFile) {\n      return null;\n    }\n    const response = await fs.promises.readFile(\n      graphFile,\n      \"utf8\",\n    );\n    return await JSON.parse(response).graph[0];\n  }\n\n  async getGraphByIdOnly(graphId: string): Promise<StaticGraph | null> {\n    const fs = await this.fs;\n    const graphFile = this.graphIdToGraphFile(graphId);\n    if (!graphFile) {\n      return null;\n    }\n    const response = await fs.promises.readFile(\n      graphFile,\n      \"utf8\",\n    );\n    return await JSON.parse(response).graph[0];\n  }\n\n  async getResource(resourceId: string): Promise<StaticResource> {\n    const fs = await this.fs;\n    const source = this.resourceIdToFile(resourceId);\n    const response = await fs.promises.readFile(\n      source,\n      \"utf8\",\n    );\n    return JSON.parse(response).then((resource: StaticResource) => {\n      resource.__source = source;\n      return resource;\n    });\n  }\n\n  async getCollection(collectionId: string): Promise<StaticCollection> {\n    const fs = await this.fs;\n    const response = await fs.promises.readFile(\n      this.collectionIdToFile(collectionId),\n      \"utf8\",\n    );\n    return await JSON.parse(response);\n  }\n\n  async getResources(\n    graphId: string,\n    limit: number | null,\n  ): Promise<StaticResource[]> {\n    const fs = await this.fs;\n    const resources = [];\n    for (const file of this.graphIdToResourcesFiles(graphId)) {\n      const response = JSON.parse(await fs.promises.readFile(file, \"utf8\"));\n      const source = file;\n      // const read = fs.createReadStream(file, { encoding: \"utf8\" });\n      // let buffer = '';\n      // let bufferLength = 0;\n      // const response: IStringKeyedObject = await (new Promise(resolve => {\n      //   read.pipe(bfj.unpipe((error: string, data: string) => {\n      //     if (error) {\n      //       throw Error(error);\n      //     }\n      //     return data;\n      //   })).on('data', (data: string) => {\n      //     const bl = Math.floor(buffer.length / 1000);\n      //     if (bl > bufferLength) {\n      //       console.log(bl);\n      //     }\n      //     bufferLength = bl;\n      //     buffer += data;\n      //   }).on('end', () => {\n      //     resolve(JSON.parse(buffer));\n      //   });\n      // }));\n\n      const resourceSet: StaticResource[] = response.business_data.resources.filter(\n        (resource: StaticResource) => graphId === resource.resourceinstance.graph_id\n      );\n      for (const resource of resourceSet) {\n        resource.__source = source;\n      }\n      resources.push(...(limit ? resourceSet.slice(0, limit) : resourceSet));\n      if (limit && resources.length > limit) {\n        break;\n      }\n    }\n    return resources;\n  }\n}\n\nconst archesClient = new ArchesClientRemote(\"http://localhost:8000\");\n\nexport {\n  archesClient,\n  ArchesClient,\n  ArchesClientRemoteStatic,\n  ArchesClientRemote,\n  ArchesClientLocal,\n  GraphResult,\n};\n","import { StaticCollection, StaticConcept } from \"./static-types\";\nimport { ArchesClient, archesClient } from \"./client\";\n\nclass ReferenceDataManager {\n  archesClient: ArchesClient;\n  collections: Map<string, Promise<StaticCollection>>;\n\n  constructor(archesClient: ArchesClient) {\n    this.archesClient = archesClient;\n    this.collections = new Map<string, Promise<StaticCollection>>();\n  }\n\n  retrieveCollection(id: string): Promise<StaticCollection> {\n    let collection = this.collections.get(id);\n    if (collection !== undefined) {\n      return collection;\n    }\n    collection = this.archesClient\n      .getCollection(id)\n      .then((jsonData) => new StaticCollection(jsonData));\n    this.collections.set(id, collection);\n    return collection;\n  }\n}\n\nconst RDM = new ReferenceDataManager(archesClient);\n\nexport { StaticCollection, ReferenceDataManager, RDM };\n","import { archesClient, ArchesClient, ArchesClientRemote } from \"./client.ts\";\nimport {\n  StaticValue,\n  StaticConcept,\n  StaticTile,\n  StaticGraph,\n  StaticNode,\n  StaticNodegroup,\n  StaticResource,\n  StaticResourceMetadata,\n} from \"./static-types\";\n\n// TODO: this does not currently cache, to avoid\n//  memory leaks.\nclass StaticStore {\n  archesClient: ArchesClient;\n  cache: Map<string, StaticResource | StaticResourceMetadata>;\n  cacheMetadataOnly: boolean;\n\n  constructor(archesClient: ArchesClient, cacheMetadataOnly: boolean = true) {\n    this.archesClient = archesClient;\n    this.cache = new Map();\n    this.cacheMetadataOnly = cacheMetadataOnly;\n  }\n\n  async getMeta(id: string, onlyIfCached: boolean = true): Promise<StaticResourceMetadata | null> {\n    if (this.cache.has(id)) {\n      const resource = this.cache.get(id);\n      if (resource instanceof StaticResource) {\n        return resource.resourceinstance;\n      }\n      return resource;\n    }\n\n    if (!onlyIfCached) {\n      const resource = await this.loadOne(id);\n      return resource.resourceinstance;\n    }\n    return null;\n  }\n\n  async* loadAll(\n    graphId: string,\n    limit: number | undefined = undefined,\n  ): AsyncIterable<StaticResource> {\n    const resourcesJSON: StaticResource[] =\n      await this.archesClient.getResources(graphId, limit || 0);\n    for (const resourceJSON of resourcesJSON.values()) {\n      const resource = new StaticResource(resourceJSON);\n      if (resource.resourceinstance.graph_id !== graphId) {\n        continue;\n      }\n      this.cache.set(\n        resource.resourceinstance.resourceinstanceid,\n        this.cacheMetadataOnly ? resource.resourceinstance : resource\n      );\n      yield resource;\n    }\n  }\n\n  async loadOne(id: string): Promise<StaticResource> {\n    if (this.cache.has(id)) {\n      const resource = this.cache.get(id);\n      if (resource instanceof StaticResource) {\n        return resource;\n      }\n    }\n\n    const resourceJSON: StaticResource =\n      await this.archesClient.getResource(id);\n    const resource = new StaticResource(resourceJSON);\n    if (this.cacheMetadataOnly) {\n      this.cache.set(id, this.cacheMetadataOnly ? resource.resourceinstance : resource);\n    }\n    return resource;\n  }\n}\n\nconst staticStore = new StaticStore(archesClient);\n\nexport { staticStore };\n","import { INodeConfig } from './interfaces';\nimport { StaticNode, StaticDomainValue } from './static-types';\n\ninterface IStaticNodeConfigDomain {\n  i18n_config: {[key: string]: string}\n  options: StaticDomainValue[];\n};\n\ninterface IStaticNodeConfigBoolean {\n  i18n_properties: string[]\n  falseLabel: {[key: string]: string}\n  trueLabel: {[key: string]: string}\n};\n\nclass StaticNodeConfigBoolean implements IStaticNodeConfigBoolean, INodeConfig {\n  i18n_properties: string[]\n  falseLabel: {[key: string]: string}\n  trueLabel: {[key: string]: string}\n\n  constructor(jsonData: IStaticNodeConfigBoolean) {\n    this.i18n_properties = jsonData.i18n_properties;\n    this.falseLabel = jsonData.falseLabel;\n    this.trueLabel = jsonData.trueLabel;\n  }\n}\n\nclass StaticNodeConfigDomain implements IStaticNodeConfigDomain, INodeConfig {\n  i18n_config: {[key: string]: string}\n  options: StaticDomainValue[];\n\n  getSelected() {\n    return this.options.find(option => option.selected);\n  }\n\n  valueFromId(id: string) {\n    return this.options.find(option => option.id == id);\n  }\n\n  constructor(jsonData: IStaticNodeConfigDomain) {\n    this.i18n_config = jsonData.i18n_config;\n    this.options = jsonData.options;\n    if (this.options) {\n      this.options = this.options.map(sdv => {\n        if (!(sdv instanceof StaticDomainValue)) {\n          return new StaticDomainValue(sdv);\n        }\n        return sdv;\n      });\n    }\n  }\n}\n\nclass NodeConfigManager {\n  static _cache: Map<string, INodeConfig | null>\n  cache: Map<string, INodeConfig | null>\n\n  constructor(cache: Map<string, INodeConfig | null> | undefined = undefined) {\n    if (!cache) {\n      cache = NodeConfigManager._cache || new Map();\n    }\n    this.cache = cache;\n  }\n\n  retrieve(node: StaticNode) {\n    if (this.cache.has(node.nodeid)) {\n      return this.cache.get(node.nodeid);\n    }\n    let nodeConfig = null;\n    switch (node.datatype) {\n      case \"boolean\":\n        // @ts-expect-error node.config is not typed\n        nodeConfig = new StaticNodeConfigBoolean(node.config);\n        break;\n      case \"domain-value-list\":\n      case \"domain-value\":\n        // @ts-expect-error node.config is not typed\n        nodeConfig = new StaticNodeConfigDomain(node.config);\n        break;\n      default:\n    };\n    this.cache.set(node.nodeid, nodeConfig);\n    return nodeConfig;\n  }\n};\n\nconst nodeConfigManager = new NodeConfigManager();\n\nexport { nodeConfigManager, StaticNodeConfigDomain, StaticNodeConfigBoolean };\n","import {\n  IStringKeyedObject,\n  IInstanceWrapper,\n  IModelWrapper,\n  IViewModel,\n  IPseudo,\n  IGraphManager,\n  IRIVM,\n  GetMeta,\n} from \"./interfaces.ts\";\nimport { PseudoValue, PseudoList } from \"./pseudos\";\nimport { RDM } from \"./rdm\";\nimport {\n  StaticNodeConfigDomain,\n  StaticNodeConfigBoolean,\n} from './nodeConfig';\nimport {\n  StaticDomainValue,\n  StaticTile,\n  StaticNode,\n  StaticValue,\n  StaticConcept,\n  StaticResource,\n  StaticResourceReference\n} from \"./static-types\";\nimport { AttrPromise } from \"./utils\";\nimport { nodeConfigManager } from './nodeConfig';\n\nconst TILE_LOADING_ERRORS = null; // \"suppress\" or \"silence\" TODO: enum\n\nconst DEFAULT_LANGUAGE = \"en\";\n\nclass ViewContext {\n  graphManager: IGraphManager | undefined\n};\nconst viewContext = new ViewContext();\n\nfunction tileLoadingError(reason: string, exc: any) {\n  if (TILE_LOADING_ERRORS !== \"silence\") {\n    console.error(reason, exc);\n    if (TILE_LOADING_ERRORS !== \"suppress\") {\n      throw exc;\n    }\n  }\n}\n\nclass ValueList<T extends IRIVM<T>> {\n  values: Map<string, any>;\n  wrapper: IInstanceWrapper<T>;\n  tiles: StaticTile[] | null;\n  promises: Map<string, boolean | Promise<boolean | IViewModel>>;\n  writeLock: null | Promise<boolean | IViewModel>;\n\n  constructor(\n    values: Map<string, any>,\n    allNodegroups: Map<string, boolean>,\n    wrapper: IInstanceWrapper<T>,\n    tiles: StaticTile[] | null,\n  ) {\n    this.values = values;\n    this.wrapper = wrapper;\n    this.tiles = tiles;\n    this.promises = allNodegroups;\n    this.writeLock = null;\n  }\n\n  async get(key: string) {\n    return this.retrieve(key, this.values.get(key), true);\n  }\n\n  set(key: string, value: any) {\n    this.values.set(key, value);\n  }\n\n  async has(key: string) {\n    await this.retrieve(key, null);\n    return this.values.has(key);\n  }\n\n  async retrieve(key: string, dflt: any = null, raiseError: boolean = false) {\n    let result: any = this.values.get(key);\n    if (Array.isArray(result)) {\n      return result;\n    }\n    const node = this.wrapper.model.getNodeObjectsByAlias().get(key);\n\n    result = await result;\n\n    if (!node) {\n      throw Error(`This key ${key} has no corresponding node`);\n    }\n    const nodegroupId = node.nodegroup_id || '';\n    const promise = node ? await this.promises.get(nodegroupId) : false;\n    // When an unloaded node is found, the whole nodegroup is loaded.\n    // The promises member ensures that no other node in the nodegroup\n    // triggers the same nodegroup load. Note that there is _also_ the\n    // individual node promise, which allows any operation to wait for\n    // just that node to finish and resolve in to the approach pseudo\n    // even if `retrieve` is not used (e.g. allEntries).\n    // _However_, this means that allEntries will not see a promise for\n    // individual nodes in the nodegroup that are _not_ the first\n    // requested, until the first requested resolves and updates the\n    // values map for all nodes in the nodegroup.\n    if (promise === false) {\n      // FIXME: the evidence is that this is not successfully functioning as\n      // a resource-wide lock...\n      await this.writeLock;\n      if (this.wrapper.resource) {\n        // Will KeyError if we do not have it.\n        const node = this.wrapper.model.getNodeObjectsByAlias().get(key);\n        if (node === undefined) {\n          throw Error(\n            \"Tried to retrieve a node key that does not exist on this resource\",\n          );\n        }\n        const values = new Map([...this.values.entries()]);\n        const promise: Promise<IViewModel | boolean> = new Promise(async (resolve) => {\n          const [ngValues] = await this.wrapper\n            .ensureNodegroup(\n              values,\n              this.promises,\n              nodegroupId,\n              this.wrapper.model.getNodeObjects(),\n              this.wrapper.model.getNodegroupObjects(),\n              this.wrapper.model.getEdges(),\n              false,\n              this.tiles,\n              true\n            );\n          let original = false;\n          for (const [k, value] of [...ngValues.entries()]) {\n            const concreteValue = await value;\n            if (key === k) {\n              // Other methods may be waiting on this specific\n              // value to resolve.\n              original = concreteValue;\n            }\n            // In theory, this should never happen when this.values[k] is\n            // not false, as the resource-wide write lock means that no other nodegroup\n            // can write. This _is_ happening however. In theory, once set, the\n            // value will be a list, so passed by reference, and so should not\n            // undo and changes that happened concurrently.\n            if (concreteValue !== false) {\n              this.values.set(k, concreteValue);\n            }\n          }\n          resolve(original);\n        });\n        // No writes should happen until this is done\n        this.writeLock = promise;\n        // No reads from this nodegroup should happen [legacy comment]\n        this.promises.set(nodegroupId, promise);\n        // Other readers are welcome to wait for this nodegroup's read\n        this.values.set(key, promise);\n        await promise;\n        this.promises.set(nodegroupId, true);\n      } else {\n        this.values.delete(key);\n      }\n      result = await this.values.get(key);\n    }\n    result = await result;\n    if (result === undefined || result === false) {\n      if (raiseError) {\n        throw Error(`Unset key ${key}`);\n      } else {\n        return dflt;\n      }\n    }\n    return result;\n  }\n\n  async setDefault(key: string, value: any) {\n    const newValue = await this.retrieve(key, value, false);\n    this.values.set(key, newValue);\n    return newValue;\n  }\n}\n\nclass ConceptListCacheEntry implements IStringKeyedObject {\n  [key: string]: any;\n  datatype: string = 'concept-list';\n  _: ConceptValueCacheEntry[];\n  meta: {[key: string]: any};\n\n  constructor({meta, _}: {meta: IStringKeyedObject | undefined, _: ConceptValueCacheEntry[]}) {\n    this._ = _.map(instance => {\n      if (instance instanceof ConceptValueCacheEntry) {\n        return instance;\n      } else if (instance) {\n        return new ConceptValueCacheEntry(instance);\n      }\n      return null;\n    }).filter(cvce => cvce !== null);\n    this.meta = meta || {};\n  }\n}\n\nclass ConceptValueCacheEntry implements IStringKeyedObject {\n  [key: string]: any\n  datatype: string = 'concept';\n  id: string;\n  value: string;\n  conceptId: string | null;\n  meta: {[key: string]: any};\n\n  constructor({meta, id, value, conceptId}: {meta: IStringKeyedObject | undefined, id: string, value: string, conceptId: string | null}) {\n    this.id = id;\n    this.value = value;\n    this.conceptId = conceptId;\n    this.meta = meta || {};\n  }\n}\n\nclass ResourceInstanceListCacheEntry implements IStringKeyedObject {\n  [key: string]: any;\n  datatype: string = 'resource-instance-list';\n  _: ResourceInstanceCacheEntry[];\n  meta: {[key: string]: any};\n\n  constructor({meta, _}: {meta: IStringKeyedObject | undefined, _: ResourceInstanceCacheEntry[]}) {\n    this._ = _.map(instance => {\n      if (instance instanceof ResourceInstanceCacheEntry) {\n        return instance;\n      }\n      return new ResourceInstanceCacheEntry(instance);\n    });\n    this.meta = meta || {};\n  }\n}\n\nclass ResourceInstanceCacheEntry implements IStringKeyedObject {\n  [key: string]: any\n  datatype: string = 'resource-instance';\n  id: string;\n  type: string;\n  graphId: string;\n  title: string | null;\n  meta: {[key: string]: any};\n\n  constructor({meta, id, type, graphId, title}: {meta: IStringKeyedObject | undefined, id: string, type: string, graphId: string, title: string | null}) {\n    this.id = id;\n    this.type = type;\n    this.graphId = graphId;\n    this.meta = meta || {};\n    this.title = this.meta.title || title;\n  }\n}\n\nclass ResourceInstanceListViewModel extends Array implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: IPseudo | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n  _value: Promise<(ResourceInstanceViewModel<any> | null)[]> | null = null;\n\n  async forJson() {\n    const value = await this._value;\n    return value ? value.map((v) => (v ? v.forJson() : null)) : null;\n  }\n\n  async __forJsonCache(getMeta: GetMeta): Promise<ResourceInstanceListCacheEntry> {\n    return new ResourceInstanceListCacheEntry({\n      meta: getMeta ? await getMeta(this) : getMeta,\n      _: await Promise.all([...this.values()].map(async (rivmPromise: Promise<ResourceInstanceViewModel<any>>) => {\n        const rivm = await rivmPromise;\n        return await rivm.__forJsonCache(getMeta)\n      }))\n    });\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n    cacheEntry: ResourceInstanceListCacheEntry | null = null\n  ): Promise<ResourceInstanceListViewModel | null> {\n    const nodeid = node.nodeid;\n    let val: (ResourceInstanceViewModel<any> | null | Promise<ResourceInstanceViewModel<any> | null>)[];\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        tile.data.set(nodeid, []);\n        if (!Array.isArray(value)) {\n          throw Error(\n            `Cannot set an (entire) resource list value on node ${nodeid} except via an array: ${JSON.stringify(value)}`,\n          );\n        }\n        val = value.map((v, i) => {\n          if (v instanceof ResourceInstanceViewModel) {\n            return v;\n          }\n          return ResourceInstanceViewModel.__create(tile, node, v, cacheEntry && cacheEntry._[i] ? cacheEntry._[i] : null);\n        });\n        Promise.all(\n          val.map(async (c) => {\n            const v = await c;\n            return v ? (await v).id : null;\n          }),\n        ).then((ids) => {\n          tile.data.set(nodeid, ids.map(id => {\n            return {\n              resourceId: id\n            };\n          }));\n          return ids;\n        });\n        value = val;\n      }\n    } else {\n      value = [];\n    }\n\n    if (!tile || !value) {\n      return null;\n    }\n    const str = new ResourceInstanceListViewModel(...value);\n    return str;\n  }\n\n  async __asTileData() {\n    return this._value ? await this._value : null;\n  }\n}\n\nclass ResourceInstanceViewModel<RIVM extends IRIVM<RIVM>> implements IStringKeyedObject {\n  [key: string | symbol]: any;\n  $: IInstanceWrapper<RIVM> | null;\n  __: IModelWrapper<RIVM> | null;\n  __parentPseudo: IPseudo | undefined = undefined;\n  __cacheEntry: ResourceInstanceCacheEntry | null = null;\n  id: string;\n  then: undefined;\n  [Symbol.toPrimitive]: undefined;\n\n  gm: IGraphManager | undefined;\n\n  toString(): string {\n    if (!this.__) {\n      return `[Resource:${this.id}]`;\n    }\n    return `[${this.__.wkrm.modelClassName}:${this.id ?? \"-\"}]`;\n  }\n\n  async __has(key: string): Promise<boolean | undefined> {\n    // There is a catch here, that because we lazy-load, we do not\n    // know, hence three possible return values.\n    if (!this.$) {\n      return undefined;\n    }\n    return (await this.$.getRootViewModel() || new Map()).__has(key);\n  }\n\n  async __asTileData(): Promise<IStringKeyedObject> {\n    return {\n      resourceId: this.id\n    };\n  }\n\n  async __forJsonCache(getMeta: GetMeta): Promise<ResourceInstanceCacheEntry> {\n    // TODO should we re-use the cacheEntry and rely on it being expired correctly?\n    let wrapper: IModelWrapper<RIVM>;\n    if (!this.__) {\n      if (this.__cacheEntry) {\n        return this.__cacheEntry;\n      } else {\n        [, wrapper] = await this.retrieve();\n      }\n    } else {\n      wrapper = this.__;\n    }\n    this.__cacheEntry = new ResourceInstanceCacheEntry({\n      meta: getMeta ? await getMeta(this) : undefined,\n      id: this.id,\n      type: wrapper.wkrm.modelClassName,\n      graphId: wrapper.wkrm.graphId,\n      title: null,\n    });\n    return this.__cacheEntry;\n  }\n\n  async forJson(cascade: boolean=false) {\n    let jsonData: StaticResourceReference;\n    if (!cascade && this.__cacheEntry) {\n      jsonData = {\n        type: this.__cacheEntry.type,\n        graphId: this.__cacheEntry.graphId,\n        id: this.__cacheEntry.id,\n        title: this.__cacheEntry.title || undefined,\n        meta: this.__cacheEntry.meta || undefined,\n        root: null\n      };\n    } else if (this.__) {\n      jsonData = {\n        type: this.__.wkrm.modelClassName,\n        graphId: this.__.wkrm.graphId,\n        id: this.id,\n        title: undefined,\n        meta: undefined,\n        root: null\n      };\n    } else {\n      jsonData = {\n        type: \"(unknown)\",\n        graphId: \"\",\n        id: this.id,\n        title: undefined,\n        meta: undefined,\n        root: null\n      };\n    }\n    const basic = new StaticResourceReference(jsonData);\n    if (cascade) {\n      if (!this.$) {\n        await this.retrieve();\n        if (!this.$) {\n          throw Error(\"Could not retrieve resource\");\n        }\n      }\n      const root = await this.$.getRootViewModel();\n      basic.root = await root.forJson();\n    }\n    return basic;\n  }\n\n  async retrieve(): Promise<[IInstanceWrapper<RIVM>, IModelWrapper<RIVM>]> {\n    let iw: IInstanceWrapper<RIVM>;\n    let mw: IModelWrapper<RIVM>;\n    if (viewContext.graphManager) {\n      const replacement = await viewContext.graphManager.getResource(this.id, true);\n\n      // @ts-expect-error We cannot guarantee this resource is the right type...\n      iw = replacement.$;\n      // @ts-expect-error We cannot guarantee this resource is the right type...\n      mw = replacement.__;\n    } else {\n      throw Error(\"Cannot traverse resource relationships without a GraphManager\");\n    }\n    this.$ = iw;\n    this.__ = mw;\n    return [iw, mw];\n  }\n\n  constructor(\n    id: string,\n    modelWrapper: IModelWrapper<RIVM> | null,\n    instanceWrapperFactory: ((\n      rivm: RIVM,\n    ) => IInstanceWrapper<RIVM>) | null,\n    cacheEntry: object | null,\n  ) {\n    this.id = id;\n    // @ts-expect-error I believe some deep type magic would be required to\n    // convince TS that `this` is a valid RIVM.\n    this.$ = instanceWrapperFactory ? instanceWrapperFactory(this) : null;\n    this.__ = modelWrapper;\n    if (cacheEntry instanceof ResourceInstanceCacheEntry) {\n      this.__cacheEntry = cacheEntry;\n    }\n\n    return new Proxy(this, {\n      // NOTE: set should not return a promise, so could cause a race\n      // condition with a subsequent read.\n      // @ts-expect-error Returning a promise for set\n      set: async (object: ResourceInstanceViewModel<RIVM>, key, value): Promise<boolean> => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          object[key] = value;\n        } else if (k in object || k.startsWith('__')) {\n          object[k] = value;\n        } else {\n          if (!object.$) {\n            await this.retrieve();\n            if (!object.$) {\n              throw Error(\"Could not retrieve resource\");\n            }\n          }\n          object.$.setOrmAttribute(k, value);\n        }\n        return true;\n      },\n      get: (object: ResourceInstanceViewModel<RIVM>, key) => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          return object[key];\n        } else if (k in object || k.startsWith('__')) {\n          return object[k];\n        }\n        return new AttrPromise(async (resolve) => {\n          if (!object.$) {\n            await this.retrieve();\n            if (!object.$) {\n              throw Error(\"Could not retrieve resource\");\n            }\n          }\n          return object.$.getOrmAttribute(k).then((v) => {\n            return resolve(v);\n          });\n        });\n      },\n    });\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n    cacheEntry: ResourceInstanceCacheEntry | null\n  ): Promise<ResourceInstanceViewModel<any> | null> {\n    const nodeid = node.nodeid;\n    let val: string | null = value;\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        if (!value && !(value instanceof StaticResource) && !(value instanceof StaticResourceReference)) {\n          val = null;\n        } else if (value instanceof Promise) {\n          return value.then((value) => {\n            return ResourceInstanceViewModel.__create(tile, node, value, cacheEntry);\n          });\n        } else if (typeof value == \"string\") {\n          if (\n            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.exec(\n              value,\n            )\n          ) {\n            val = value;\n          } else {\n            throw Error(\n              `Set resource instances using id, not strings in node ${node.alias}: ${value}`,\n            );\n          }\n        } else if (value instanceof Object && value.resourceId) {\n          val = value.resourceId;\n        } else if (value instanceof Array && value.length < 2 ) {\n          if (value.length == 1) {\n            return ResourceInstanceViewModel.__create(tile, node, value[0], cacheEntry);\n          }\n        } else {\n          throw Error(\"Could not set resource instance from this data\");\n        }\n\n        tile.data.set(nodeid, val ? [{resourceId: val}] : null);\n      }\n    }\n\n    if (!tile || !val) {\n      return null;\n    }\n    const str = new ResourceInstanceViewModel(val, null, null, cacheEntry);\n    return str;\n  }\n}\n\nclass FileListViewModel extends Array implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: IPseudo | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n  _value: Promise<(ConceptValueViewModel | null)[]> | null = null;\n\n  async forJson() {\n    const value = await this._value;\n    return value ? value.map((v) => (v ? v.forJson() : null)) : null;\n  }\n\n  async __forJsonCache(): Promise<null> {\n    return null;\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): Promise<FileListViewModel> {\n    const nodeid = node.nodeid;\n    let val: (ConceptValueViewModel | Promise<ConceptValueViewModel | null> | null)[] = [];\n    if (!tile.data.has(nodeid)) {\n      tile.data.set(nodeid, null);\n    }\n    if (value !== null) {\n      tile.data.set(nodeid, []);\n      if (!Array.isArray(value)) {\n        throw Error(\n          `Cannot set an (entire) file list value on node ${nodeid} except via an array: ${JSON.stringify(value)}`,\n        );\n      }\n      val = value.map((c) => {\n        return c;\n      });\n      Promise.all(val).then((vals) => {\n        Promise.all(\n          vals.map(async (c) => {\n            const v = await c;\n            return v ? (await v.getValue()).id : null;\n          })\n        ).then((ids) => {\n          tile.data.set(nodeid, ids);\n        });\n      });\n      value = val;\n    } else {\n      value = [];\n    }\n\n    const str = new FileListViewModel(...value);\n    return str;\n  }\n\n  async __asTileData() {\n    return this._value ? await this._value : null;\n  }\n}\n\nclass ConceptListViewModel extends Array implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: IPseudo | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n  _value: Promise<(ConceptValueViewModel | null)[]> | null = null;\n\n  async forJson() {\n    const value = await this._value;\n    return value ? value.map((v) => (v ? v.forJson() : null)) : null;\n  }\n\n  async __forJsonCache(getMeta: GetMeta): Promise<ConceptListCacheEntry> {\n    return new ConceptListCacheEntry({\n      meta: getMeta ? await getMeta(this) : getMeta,\n      _: await Promise.all([...this.values()].map(async (rivmPromise: Promise<ConceptValueViewModel>) => {\n        const rivm = await rivmPromise;\n        if (rivm) {\n          return await rivm.__forJsonCache(getMeta)\n        }\n      }))\n    });\n  }\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n    cacheEntry: ConceptListCacheEntry | null = null\n  ): Promise<ConceptListViewModel> {\n    const nodeid = node.nodeid;\n    let val: (ConceptValueViewModel | Promise<ConceptValueViewModel | null> | null)[] = [];\n    if (!tile.data.has(nodeid)) {\n      tile.data.set(nodeid, null);\n    }\n    if (value !== null) {\n      tile.data.set(nodeid, []);\n      if (!Array.isArray(value)) {\n        throw Error(\n          `Cannot set an (entire) concept list value on node ${nodeid} except via an array: ${JSON.stringify(value)}`,\n        );\n      }\n      val = value.map((c, i) => {\n        if (c instanceof ConceptValueViewModel) {\n          return c;\n        }\n        return ConceptValueViewModel.__create(tile, node, c, cacheEntry && cacheEntry._[i] ? cacheEntry._[i] : null);\n      });\n      Promise.all(val).then((vals) => {\n        Promise.all(\n          vals.map(async (c) => {\n            const v = await c;\n            return v ? (await v.getValue()).id : null;\n          })\n        ).then((ids) => {\n          tile.data.set(nodeid, ids);\n        });\n      });\n      value = val;\n    } else {\n      value = [];\n    }\n\n    const str = new ConceptListViewModel(...value);\n    return str;\n  }\n\n  async __asTileData() {\n    return this._value ? await this._value : null;\n  }\n}\n\nclass DomainValueListViewModel extends Array implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n  _value: Promise<(DomainValueViewModel | null)[]> | null = null;\n\n  async forJson() {\n    const value = await this._value;\n    return value ? value.map((v) => (v ? v.forJson() : null)) : null;\n  }\n\n  // No point in caching something that is on the graph.\n  __forJsonCache(): null {\n    return null;\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): Promise<DomainValueListViewModel> {\n    const nodeid = node.nodeid;\n    let val: (DomainValueViewModel | Promise<DomainValueViewModel | null> | null)[];\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        tile.data.set(nodeid, []);\n        if (!Array.isArray(value)) {\n          throw Error(\n            `Cannot set an (entire) domain list value on node ${nodeid} except via an array: ${JSON.stringify(value)}`,\n          );\n        }\n        val = value.map((c) => {\n          if (c instanceof DomainValueViewModel) {\n            return c;\n          }\n          return DomainValueViewModel.__create(tile, node, c);\n        });\n        Promise.all(val).then(async (vals) => {\n          const ids = Promise.all(vals.map(async val => val === null ? val : (await val._value).id));\n          ids.then(ids => {\n            tile.data.set(nodeid, ids);\n          });\n        });\n      }\n    } else {\n      value = [];\n    }\n\n    const str = new DomainValueListViewModel(...value);\n    return str;\n  }\n\n  async __asTileData() {\n    const value = await this._value;\n    return value ?? null;\n  }\n}\n\n\n\nclass DomainValueViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  _value: StaticDomainValue | Promise<StaticDomainValue>;\n\n  constructor(value: StaticDomainValue) {\n    super(value.toString());\n    this._value = value;\n  }\n\n  async forJson(): Promise<StaticDomainValue> {\n    return this._value;\n  }\n\n  // No point in caching something that is on the graph.\n  __forJsonCache(): null {\n    return null;\n  }\n\n  getValue(): StaticDomainValue | Promise<StaticDomainValue> {\n    return this._value;\n  }\n\n  async lang(lang: string): Promise<string | undefined> {\n    return (await this._value).lang(lang);\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): Promise<DomainValueViewModel | null> {\n    const nodeid = node.nodeid;\n    let val: StaticDomainValue | null = value;\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        if (!value && !(value instanceof StaticDomainValue)) {\n          val = null;\n        } else if (value instanceof Promise) {\n          return value.then((value) => {\n            return DomainValueViewModel.__create(tile, node, value);\n          });\n        } else if (typeof value == \"string\") {\n          if (\n            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i.exec(\n              value,\n            )\n          ) {\n            const config = nodeConfigManager.retrieve(node);\n            if (!config || !(config instanceof StaticNodeConfigDomain)) {\n              throw Error(`Cannot form domain value for ${node.nodeid} without config`);\n            }\n            val = config.valueFromId(value) || null;\n          } else {\n            throw Error(\n              \"Set domain values using values from domain lists, not strings\",\n            );\n          }\n        } else {\n          throw Error(\"Could not set domain value from this data\");\n        }\n\n        if (!(val instanceof Promise)) {\n          tile.data.set(nodeid, val ? val.id : null);\n        }\n      }\n    }\n\n    if (!tile || !val) {\n      return null;\n    }\n    const str = new DomainValueViewModel(val);\n    return str;\n  }\n\n  async __asTileData() {\n    const value = await this._value;\n    return value ? value.id : null;\n  }\n}\n\nclass ConceptValueViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: IPseudo | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  _value: StaticValue | Promise<StaticValue>;\n\n  constructor(value: StaticValue) {\n    super(value.value);\n    this._value = value;\n  }\n\n  async forJson(): Promise<StaticValue> {\n    return this._value;\n  }\n\n  async __forJsonCache(getMeta: GetMeta): Promise<ConceptValueCacheEntry> {\n    const value = await this._value;\n    return new ConceptValueCacheEntry({\n      meta: getMeta ? await getMeta(this) : undefined,\n      id: value.id,\n      value: value.value,\n      conceptId: value.__conceptId\n    });\n  }\n\n  getValue(): StaticValue | Promise<StaticValue> {\n    return this._value;\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n    cacheEntry: ConceptValueCacheEntry | null\n  ): Promise<ConceptValueViewModel | null> {\n    const nodeid = node.nodeid;\n    let val: StaticValue | null = value;\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        if (value instanceof StaticConcept) {\n          val = value.getPrefLabel();\n        }\n        if (!value) {\n          val = null;\n        } else if (value instanceof StaticValue) {\n          // No change needed.\n        } else if (value instanceof Promise) {\n          return value.then((value) => {\n            return ConceptValueViewModel.__create(tile, node, value, cacheEntry);\n          });\n        } else if (typeof value == \"string\") {\n          if (\n            /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.exec(\n              value,\n            )\n          ) {\n            if (cacheEntry) {\n              val = new StaticValue({\n                id: cacheEntry.id,\n                value: cacheEntry.value,\n                __concept: null,\n                __conceptId: cacheEntry.conceptId,\n              }, cacheEntry.conceptId);\n              return new ConceptValueViewModel(val);\n            } else {\n              const collectionId = node.config[\"rdmCollection\"];\n              const collection = RDM.retrieveCollection(collectionId);\n              return collection.then((collection) => {\n                const val = collection.getConceptValue(value);\n\n                if (!val) {\n                  console.error(\"Could not find concept for value\", value, \"for\", node.alias, \"in collection\", collectionId);\n                }\n\n                tile.data.set(nodeid, val ? val.id : null);\n\n                if (!tile || !val) {\n                  return null;\n                }\n                const str = new ConceptValueViewModel(val);\n\n                return str;\n              });\n            }\n          } else {\n            throw Error(\n              `Set concepts using values from collections, not strings: ${value}`,\n            );\n          }\n        } else {\n          throw Error(\"Could not set concept from this data\");\n        }\n\n        if (!(val instanceof Promise)) {\n          if (!val) {\n            console.error(\"Could not find concept for value\", value, \"for\", node.alias, \"in collection\", node.config.get(\"rdmCollection\"));\n          }\n\n          tile.data.set(nodeid, val ? val.id : null);\n        }\n      }\n    }\n\n    if (!tile || !val) {\n      return null;\n    }\n    const str = new ConceptValueViewModel(val);\n    return str;\n  }\n\n  async __asTileData() {\n    const value = await this._value;\n    return value ? value.id : null;\n  }\n}\n\nclass DateViewModel extends Date implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n  __original: string;\n  then: undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  constructor(val: string) {\n    super(val);\n    this.__original = val;\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): DateViewModel | Promise<DateViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) =>\n        DateViewModel.__create(tile, node, value),\n      );\n    }\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    let val: string | {[key: string]: string} | any = tile.data.get(nodeid);\n    // TODO: catch rendering issues - this workaround should be removed\n    // as it is overly tolerant of input issues.\n    if (typeof val == \"object\" && val['en'] !== undefined) {\n      val = val.en;\n    }\n    if (!tile || val === null || val === undefined || val === '') {\n      return null;\n    }\n    if (typeof val != \"string\") {\n      throw Error(\"Date should be a string\");\n    }\n    const str = new DateViewModel(val);\n    return str;\n  }\n\n  async forJson() {\n    try {\n      return this.toISOString();\n    } catch (e) {\n      console.warn(e);\n      return this.__original;\n    }\n  }\n\n  __asTileData() {\n    return this.toISOString();\n  }\n}\n\nclass GeoJSONViewModel implements IViewModel, IStringKeyedObject {\n  [key: string | symbol]: any;\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n  then: undefined;\n  [Symbol.toPrimitive]: undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  _value: { [key: string]: any };\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  constructor(jsonData: { [key: string]: any }) {\n    this._value = jsonData;\n    return new Proxy(this, {\n      get: (object: GeoJSONViewModel, key) => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          return object[key];\n        } else if (k in object) {\n          return object[k];\n        }\n        return this._value[k];\n      },\n      set: (object: GeoJSONViewModel, key, value) => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          object[key] = value;\n        } else if (k in object) {\n          object[k] = value;\n        } else {\n          this._value[k] = value;\n        }\n        return true;\n      },\n    });\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): GeoJSONViewModel | Promise<GeoJSONViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) =>\n        GeoJSONViewModel.__create(tile, node, value),\n      );\n    }\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, null);\n      }\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    if (!(val instanceof Object)) {\n      throw Error(\"GeoJSON should be a JSON object\");\n    }\n    const str = new GeoJSONViewModel(val);\n    return str;\n  }\n\n  async forJson() {\n    return await this._value;\n  }\n\n  __asTileData() {\n    return this._value;\n  }\n}\n\nclass StringTranslatedLanguage {\n  value: string = \"\"\n}\n\nclass EDTFViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  forJson(): string {\n    return this.toString();\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): EDTFViewModel | Promise<EDTFViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => EDTFViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    const string = new EDTFViewModel(val);\n    return string;\n  }\n\n  __asTileData() {\n    return `${this}`;\n  }\n}\n\nclass NonLocalizedStringViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  forJson(): string {\n    return this.toString();\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): NonLocalizedStringViewModel | Promise<NonLocalizedStringViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => NonLocalizedStringViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    const string = new NonLocalizedStringViewModel(val);\n    return string;\n  }\n\n  __asTileData() {\n    return `${this}`;\n  }\n}\n\nclass NumberViewModel extends Number implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  toString(): string {\n    return `${this.valueOf()}`;\n  }\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  forJson(): number {\n    return this.valueOf();\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): NumberViewModel | Promise<NumberViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => NumberViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    const num = new NumberViewModel(val);\n    return num;\n  }\n\n  __asTileData() {\n    return this ? true : false;\n  }\n}\n\nclass BooleanViewModel extends Boolean implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n  __config:  StaticNodeConfigBoolean;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  constructor(value: boolean, config: StaticNodeConfigBoolean) {\n    super(value);\n    this.__config = config;\n  }\n\n  toString(lang?: string | undefined): string {\n    const labelLang = lang || DEFAULT_LANGUAGE;\n    const isTrue: Boolean = this;\n    return isTrue ? (\n      this.__config && this.__config.trueLabel ? this.__config.trueLabel[labelLang] || 'true' : 'true'\n    ) : (\n      this.__config && this.__config.trueLabel ? this.__config.falseLabel[labelLang] || 'false' : 'false'\n    );\n  }\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  forJson(): boolean {\n    return this ? true : false;\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): BooleanViewModel | Promise<BooleanViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => BooleanViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (value !== null) {\n        tile.data.set(nodeid, value);\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    const config = nodeConfigManager.retrieve(node);\n    if (!config || !(config instanceof StaticNodeConfigBoolean)) {\n      throw Error(`Cannot form boolean value for ${node.nodeid} without config`);\n    }\n    const bool = new BooleanViewModel(val, config);\n    return bool;\n  }\n\n  __asTileData() {\n    return this ? true : false;\n  }\n}\n\nclass Url {\n  url: string\n  url_label?: string\n\n  constructor(url: string, url_label?: string) {\n    this.url = url;\n    this.url_label = url_label;\n  }\n}\n\nclass UrlViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  _value: Url;\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  constructor(value: Url) {\n    const displayValue = value.url_label || value.url;\n    super(displayValue);\n    this._value = value;\n  }\n\n  forJson(): {[key: string]: string} {\n    return {\n      url: this._value.url,\n      url_label: this._value.url_label || \"\",\n    };\n  }\n\n  label() {\n    return this._value.url_label || this._value.url;\n  }\n\n  href() {\n    return this._value.url;\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): UrlViewModel | Promise<UrlViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => UrlViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, {});\n      }\n      if (value !== null) {\n        if (value instanceof UrlViewModel) {\n          value = value._value;\n        } else if (value instanceof Object) {\n          if (!value.url) {\n            throw Error(`A URL must be null or have a 'url' field: ${value}`);\n          }\n        }\n        tile.data.set(nodeid, {\n          url: value.url,\n          url_label: value.url_label,\n        });\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    let url: Url;\n    if (typeof val !== 'object') {\n      url = new Url(`${val}`);\n    } else if (val instanceof Map) {\n      url = new Url(val.get('url'), val.get('url_label'));\n    } else if ('url' in val && typeof val === 'object' && typeof val.url === 'string' && 'url_label' in val && (val.url_label === undefined || typeof val.url_label === 'string')) {\n      url = new Url(val.url, val.url_label);\n    } else {\n      throw Error(`Unrecognised URL type: ${val}`);\n    }\n    const str = new UrlViewModel(url);\n    return str;\n  }\n\n  __asTileData() {\n    return this.forJson();\n  }\n}\n\nclass StringViewModel extends String implements IViewModel {\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  __parentPseudo: PseudoValue | undefined;\n\n  describeField = () => (this.__parentPseudo ? this.__parentPseudo.describeField() : null)\n  describeFieldGroup = () => (this.__parentPseudo ? this.__parentPseudo.describeFieldGroup() : null)\n\n  _value: Map<string, StringTranslatedLanguage>;\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  constructor(value: Map<string, StringTranslatedLanguage>, language: string | null = null) {\n    const lang = value.get(language || DEFAULT_LANGUAGE);\n    let displayValue: string;\n    if (lang) {\n      if (typeof lang == \"string\") {\n        displayValue = lang;\n      } else {\n        displayValue = lang.value;\n      }\n    } else {\n      // TODO: allow fallback\n      displayValue = \"\";\n    }\n    super(displayValue);\n    this._value = value;\n  }\n\n  forJson(): string {\n    return `${this}`;\n  }\n\n  lang(language: string) {\n    const elt = this._value.get(language);\n    if (elt) {\n      if (elt instanceof Object) {\n        return elt.value;\n      }\n      return elt;\n    } else {\n      return undefined;\n    }\n  }\n\n  static __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n  ): StringViewModel | Promise<StringViewModel | null> | null {\n    const nodeid = node.nodeid;\n    if (value instanceof Promise) {\n      return value.then((value) => StringViewModel.__create(tile, node, value));\n    }\n    if (tile) {\n      if (!tile.data.has(nodeid)) {\n        tile.data.set(nodeid, {});\n      }\n      if (value !== null) {\n        if (value instanceof Object) {\n          const entries =\n            value instanceof Map ? value.entries() : Object.entries(value);\n          for (const [k, v] of [...entries]) {\n            const val = tile.data.get(nodeid);\n            if (val instanceof Map) {\n              val.set(k, v);\n            } else if (val instanceof Object) {\n              // @ts-expect-error Need better typing of data to make this settable.\n              val[k] = v;\n            } else if (val !== null) {\n              throw Error(\"Malformed string in tile data\");\n            }\n          }\n        } else {\n          tile.data.set(nodeid, {\n            [DEFAULT_LANGUAGE]: value,\n          });\n        }\n      }\n    }\n\n    const val = tile.data.get(nodeid);\n    if (!tile || val === null || val === undefined) {\n      return null;\n    }\n    let mapVal;\n    if (val instanceof Map) {\n      mapVal = val;\n    } else {\n      mapVal = new Map(Object.entries(val));\n    }\n    const str = new StringViewModel(mapVal);\n    return str;\n  }\n\n  __asTileData() {\n    return this._value;\n  }\n}\n\nclass SemanticViewModel implements IStringKeyedObject, IViewModel {\n  [key: string | symbol]: any;\n  _: IViewModel | Promise<IViewModel> | undefined = undefined;\n  then: undefined;\n  [Symbol.toPrimitive]: undefined;\n\n  __parentPseudo: PseudoValue | undefined;\n  __childValues: Map<string, any>;\n  __parentWkri: IRIVM<any> | null;\n  __childNodes: Map<string, StaticNode>;\n  __tile: StaticTile | null;\n  __node: StaticNode;\n\n  __forJsonCache(): null {\n    return null;\n  }\n\n  constructor(\n    parentWkri: IRIVM<any> | null,\n    childNodes: Map<string, StaticNode>,\n    tile: StaticTile | null,\n    node: StaticNode,\n  ) {\n    this.__childValues = new Map<string, any>();\n    this.__parentWkri = parentWkri;\n    this.__tile = tile;\n    this.__node = node;\n    this.__childNodes = childNodes;\n    return new Proxy(this, {\n      set: (object, key, value) => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          object[key] = value;\n        } else if (k.startsWith(\"__\") || k in object) {\n          object[k] = value;\n        } else {\n          object.__set(k, value);\n        }\n        return true;\n      },\n      get: (object, key) => {\n        const k: string = typeof key === 'symbol' ? key.description || '' : key;\n        if (key in object) {\n          return object[key];\n        } else if (k.startsWith(\"__\") || k in object) {\n          return object[k];\n        }\n        if (k == \"length\") {\n          return object.__childNodes.size;\n        }\n        return new AttrPromise((resolve) => {\n          object.__get(k).then(resolve);\n        });\n      },\n    });\n  }\n\n  async toString(): Promise<string> {\n    const entries = [...this.__childValues.entries()].map(([k, v]) => `${k}: ${v}`);\n    return `[[${entries.join(\",\")}]]`;\n  }\n\n  async toObject() {\n    const entries = [...(await this.__getChildValues()).entries()];\n    return Object.fromEntries(await Promise.all(entries.map(async ([k, vl]) => {\n        return [k, (await vl).getValue()];\n    })));\n  }\n\n  async forJson() {\n    async function _forJson(v: IPseudo | IViewModel | null) {\n      v = await v;\n      if (!v) {\n        return null;\n      }\n      return await v.forJson();\n    };\n    const entries = [...(await this.__getChildValues()).entries()];\n    return Object.fromEntries(await Promise.all(entries.map(async ([k, vl]) => {\n        return [k, vl ? await _forJson(vl) : vl];\n    })));\n  }\n\n  async __update(map: Map<string, any>) {\n    return Promise.all(\n      [...map.entries()].map(([k, v]) => {\n        this.__set(k, v);\n      }),\n    );\n  }\n\n  async __get(key: string) {\n    const childValue = await this.__getChildValue(key);\n    return childValue.getValue();\n  }\n\n  async __set(key: string, value: any) {\n  // async __set(key: string, value: any) {\n    if (!this.__childNodes.has(key)) {\n      throw Error(\n        `Semantic node does not have this key: ${key} (${[...this.__childNodes.keys()]})`,\n      );\n    }\n\n    throw Error(`Setting semantic keys (${key} = ${value}) is not implemented yet in Javascript`);\n    // const child = await this.__getChildValue(key, true);\n    // child.value = value;\n  }\n\n  __has(key: string) {\n    return this.__childNodes.has(key);\n  }\n\n  async __getChildTypes() {\n    const promises = [...this.__childNodes.keys()].map(async (key): Promise<[string, IPseudo]> => [\n      key,\n      await this.__getChildValue(key),\n    ]);\n    const entries: Array<[string, IPseudo]> = await Promise.all(promises);\n    return new Map<string, any>([...entries]);\n  }\n\n  async __getChildren(direct: null | boolean = null) {\n    const items = new Map<string, any>();\n    for (const [key, value] of [...(await this.__getChildValues()).entries()]) {\n      items.set(key, value);\n    }\n    const children = [...items.entries()]\n      .filter((entry) => {\n        const child = this.__childNodes.get(entry[0]);\n        if (!child) {\n          throw Error(\"Child key is not in child nodes\");\n        }\n        return (\n          (direct === null || direct === !child.is_collector) &&\n          entry[1] !== null\n        );\n      })\n      .map((entry) => entry[1]);\n    return children;\n  }\n\n  async __getChildValue(key: string, setDefault: boolean = false): Promise<IPseudo> {\n    if (!this.__childNodes.has(key)) {\n      throw Error(\n        `Semantic node does not have this key: ${key} (${[...this.__childNodes.keys()]})`,\n      );\n    }\n\n    let child;\n    if (!this.__childValues.has(key)) {\n      const children = await this.__getChildValues();\n      child = children.get(key) || null;\n\n      let set = true;\n      if (child === null) {\n        child = this.__makePseudo(key);\n        set = setDefault;\n      }\n      if (set) {\n        // This ensures that we do not set a default value in our\n        // local cache simply because the node is not loaded yet.\n        this.__childValues.set(key, child);\n      }\n      child.parentNode = this.__parentPseudo || null;\n    } else {\n      child = this.__childValues.get(key);\n    }\n    return child;\n  }\n\n  __makePseudo(key: string): IPseudo {\n    const childNode = this.__childNodes.get(key);\n\n    if (!childNode) {\n      throw Error(`Child node key ${key} missing`);\n    }\n\n    if (!this.__parentWkri) {\n      throw Error(\"This semantic node is currently parentless (no WKRI)\");\n    }\n\n    if (!this.__parentWkri.$) {\n      // Could autoretreive?\n      throw Error(\"This semantic node is currently on an unloaded WKRI\");\n    }\n\n    const child = this.__parentWkri.$.addPseudo(childNode, this.__tile, this.__node);\n    child.parentNode = this.__parentPseudo || null;\n    return child;\n  }\n\n  static async __create(\n    tile: StaticTile,\n    node: StaticNode,\n    value: any,\n    parent: IRIVM<any> | null,\n    childNodes: Map<string, StaticNode>,\n  ): Promise<SemanticViewModel> {\n    const svm = new SemanticViewModel(parent, childNodes, tile, node);\n    if (value) {\n      try {\n        await svm.__update(value);\n      } catch (e) {\n        tileLoadingError(\n          `\n          Suppressed a tile loading error: ${e}: ${typeof e} (tile: ${tile}; node: ${node}) - ${value}\n        `,\n          e,\n        );\n      }\n    }\n    // await svm.__getChildren();\n    return svm;\n  }\n\n  async __asTileData() {\n    // Ensure all nodes have populated the tile\n    const relationships: any[] = [];\n    for (const value of [...await this.__getChildren(true)]) {\n      // We do not use tile, because a child node will ignore its tile reference.\n      const [, subrelationships] = await value.getTile();\n      relationships.push(...subrelationships);\n    }\n    // This is none because the semantic type has no nodal value,\n    // only its children have nodal values, and the nodal value of this nodeid should\n    // not exist.\n    return [null, relationships];\n  }\n\n  async __getChildValues(): Promise<Map<string, IPseudo>> {\n    const parent = this.__parentWkri;\n    const childNodes = this.__childNodes;\n    const tile = this.__tile;\n    const node = this.__node;\n    if (!parent || !parent.$) {\n      return new Map();\n    }\n\n    // Ensure lazy-loading done.\n    // TODO check this does not go deeper than necessary.\n    await parent.$.loadNodes([...childNodes.keys()]);\n\n    // TODO: Why not just use edges?\n    const children: Map<string, any> = new Map();\n    for (const entry of [...parent.$.allEntries()]) {\n      const key = entry[0];\n      let values = entry[1];\n      if (values instanceof Promise) {\n        values = await values;\n      }\n      if (values === false || values === null || values === undefined) {\n        continue;\n      }\n      const childNode = childNodes.get(key);\n      if (childNode) {\n        for (let value of values) {\n          if (\n            value !== null &&\n            value.node &&\n            (!(value.parentNode) ||\n              value.parentNode === this.__parentPseudo)\n          ) {\n            // It is possible that this value has already\n            // been requested, but the tile is in-flight.\n            value = await value;\n            if (!value.node) {\n              throw Error(`Node ${childNode.alias} (${childNode.nodeid}) is unavailable`);\n            }\n            if (\n              // value.node.nodegroup_id == node.nodeid in all cases for first possibility?\n              (value.node.nodegroup_id != node.nodegroup_id && tile && value.tile && (!(value.tile.parenttile_id) || value.tile.parenttile_id == tile.tileid)) ||\n              (value.node.nodegroup_id == node.nodegroup_id &&\n                tile &&\n                value.tile == tile &&\n                !childNode.is_collector) //  # It shares a tile\n              // it feels like this should be necessary, but area_assignments->area_assignment fails with null parenttile_id\n              // (tile && value.tile && value.tile.parenttile_id == tile.tileid) ||\n              // (value.node.nodegroup_id == node.nodegroup_id &&\n              //   tile &&\n              //   value.tile == tile &&\n              //   !childNode.is_collector) //  # It shares a tile\n            ) {\n              children.set(key, value);\n            } else if (\n              node.nodegroup_id != value.node.nodegroup_id &&\n              childNode.is_collector // It does not share a tile\n            ) {\n              // This avoids list types that have their own tiles (like resource or concept lists)\n              // from appearing doubly-nested\n              const childValue = value instanceof PseudoList ? value : (value.isIterable() ? await value.getValue() : null);\n              let listValue: PseudoList | Array<any> | null;\n              if (childValue && Array.isArray(childValue)) {\n                listValue = childValue;\n              } else {\n                listValue = null;\n              }\n              if (listValue !== null) {\n                if (children.has(key)) {\n                  children.get(key).push(...listValue);\n                } else {\n                  children.set(key, listValue);\n                }\n              } else {\n                // In this case, we have a value, but the wrapper logic did not make it a PseudoList, so\n                // we should treat it as singular.\n                children.set(key, value);\n              }\n            }\n          }\n        }\n      }\n    }\n    for (const [key, value] of [...children.entries()]) {\n      value.parentNode = this.__parentPseudo;\n      this.__childValues.set(key, value);\n    }\n\n    return children;\n  }\n}\n\nconst CUSTOM_DATATYPES: Map<string, string | IViewModel> = new Map();\n\nasync function getViewModel<RIVM extends IRIVM<RIVM>>(\n  parentPseudo: PseudoValue,\n  tile: StaticTile,\n  node: StaticNode,\n  data: any,\n  parent: IRIVM<RIVM> | null,\n  childNodes: Map<string, StaticNode>,\n  isInner: boolean = false\n): Promise<IViewModel | null> {\n  let vm;\n  // TODO: should parentPseudo.parent.$ trigger a retrieve if missing?\n  const cacheEntries: {[tileId: string]: {[nodeId: string]: IStringKeyedObject}} | undefined = parentPseudo.parent && parentPseudo.parent.$ ? await parentPseudo.parent.$.getValueCache(false, undefined) : undefined;\n  let cacheEntry: IStringKeyedObject | null = null;\n  if (cacheEntries) {\n    cacheEntry = (tile.tileid ? (cacheEntries[tile.tileid] ?? {}) : {})[node.nodeid]\n  };\n  const datatype = isInner ? \"semantic\" : CUSTOM_DATATYPES.get(node.datatype) ?? node.datatype;\n  if (!(typeof datatype == \"string\")) {\n    // @ts-expect-error Cannot make a static member part of the interface\n    vm = await datatype.__create(tile, node, data, cacheEntry);\n  } else {\n    switch (datatype) {\n      case \"semantic\":\n        vm = await SemanticViewModel.__create(\n          tile,\n          node,\n          data,\n          parent,\n          childNodes,\n        );\n        break;\n      case \"domain-value\":\n        vm = await DomainValueViewModel.__create(tile, node, data);\n        break;\n      case \"domain-value-list\":\n        vm = await DomainValueListViewModel.__create(tile, node, data);\n        break;\n      case \"concept\":\n        if (cacheEntry && typeof cacheEntry === \"object\" && !(cacheEntry instanceof ConceptValueCacheEntry)) {\n          // @ts-expect-error We do not know the cache entry is structured correctly, and any such checks are in the constructor.\n          cacheEntry = new ConceptValueCacheEntry(cacheEntry);\n          // console.warn(`Cache entry for tile ${tile.tileid} on node ${node.nodeid} is not of type ConceptValueCacheEntry`);\n        }\n        vm = await ConceptValueViewModel.__create(tile, node, data, cacheEntry);\n        break;\n      case \"resource-instance\":\n        if (cacheEntry && typeof cacheEntry === \"object\" && !(cacheEntry instanceof ResourceInstanceCacheEntry)) {\n          // @ts-expect-error We do not know the cache entry is structured correctly, and any such checks are in the constructor.\n          cacheEntry = new ResourceInstanceCacheEntry(cacheEntry);\n          // console.warn(`Cache entry for tile ${tile.tileid} on node ${node.nodeid} is not of type ResourceInstanceCacheEntry`);\n        }\n        vm = await ResourceInstanceViewModel.__create(tile, node, data, cacheEntry);\n        break;\n      case \"resource-instance-list\":\n        if (cacheEntry && typeof cacheEntry === \"object\" && !(cacheEntry instanceof ResourceInstanceListCacheEntry)) {\n          // @ts-expect-error We do not know the cache entry is structured correctly, and any such checks are in the constructor.\n          cacheEntry = new ResourceInstanceListCacheEntry(cacheEntry);\n          // console.warn(`Cache entry for tile ${tile.tileid} on node ${node.nodeid} is not of type ResourceInstanceListCacheEntry`);\n        }\n        vm = await ResourceInstanceListViewModel.__create(tile, node, data, cacheEntry);\n        break;\n      case \"concept-list\":\n        if (cacheEntry && typeof cacheEntry === \"object\" && !(cacheEntry instanceof ConceptListCacheEntry)) {\n          // @ts-expect-error We do not know the cache entry is structured correctly, and any such checks are in the constructor.\n          cacheEntry = new ConceptListCacheEntry(cacheEntry);\n          // console.warn(`Cache entry for tile ${tile.tileid} on node ${node.nodeid} is not of type ConceptListCacheEntry`);\n        }\n        vm = await ConceptListViewModel.__create(tile, node, data, cacheEntry);\n        break;\n      case \"date\":\n        vm = await DateViewModel.__create(tile, node, data);\n        break;\n      case \"geojson-feature-collection\":\n        vm = await GeoJSONViewModel.__create(tile, node, data);\n        break;\n      case \"boolean\":\n        vm = await BooleanViewModel.__create(tile, node, data);\n        break;\n      case \"string\":\n        vm = await StringViewModel.__create(tile, node, data);\n        break\n      case \"number\":\n        vm = await NumberViewModel.__create(tile, node, data);\n        break\n      case \"file-list\":\n        vm = await FileListViewModel.__create(tile, node, data);\n        break;\n      case \"edtf\":\n        vm = await EDTFViewModel.__create(tile, node, data);\n        break;\n      case \"url\":\n        vm = await UrlViewModel.__create(tile, node, data);\n        break;\n      case \"non-localized-string\":\n        vm = await NonLocalizedStringViewModel.__create(tile, node, data);\n        break;\n      default:\n        console.warn(\"Missing type for tile\", tile.tileid, \"on node\", node.alias, \"with type\", node.datatype);\n        vm = await NonLocalizedStringViewModel.__create(tile, node, data);\n    }\n  }\n\n  if (vm === null) {\n    return null;\n  }\n\n  vm.__parentPseudo = parentPseudo;\n  if (vm instanceof Array) {\n    for (const vme of vm) {\n      if (vme instanceof Promise) {\n        vme.then(vmep => { if (vmep !== null) vmep.__parentPseudo = parentPseudo; });\n      } else {\n        vme.__parentPseudo = parentPseudo;\n      }\n    }\n  }\n\n  return vm;\n}\n\nexport { ResourceInstanceCacheEntry, DEFAULT_LANGUAGE, ResourceInstanceViewModel, ValueList, getViewModel, DomainValueViewModel, SemanticViewModel, StringViewModel, DateViewModel, GeoJSONViewModel, ConceptValueViewModel, viewContext, NonLocalizedStringViewModel, CUSTOM_DATATYPES, BooleanViewModel, NumberViewModel, UrlViewModel };\n","import { StaticTile, StaticNode } from \"./static-types\";\nimport { ISemantic, IViewModel, IPseudo, IRIVM, IModelWrapper } from \"./interfaces\";\nimport { getViewModel } from \"./viewModels\";\nimport { AttrPromise } from \"./utils\";\n\nclass PseudoUnavailable implements IPseudo {\n  parentNode: PseudoValue<any> | null = null;\n  tile: null = null;\n  node: StaticNode;\n  isOuter: boolean = false;\n\n  constructor(node: StaticNode) {\n    this.node = node;\n  }\n\n  async forJson(): Promise<{[key: string]: any}[] | null> {\n    return null;\n  }\n\n  describeField() {\n    return \"Unavailable field\";\n  }\n\n  describeFieldGroup() {\n    return \"Unavailable field\";\n  }\n\n  getValue(): AttrPromise<null> {\n    return new AttrPromise(resolve => resolve(null));\n  }\n\n  getLength() {\n    return 0;\n  }\n\n  getChildren(_: boolean = false) {\n    return [];\n  }\n\n  isIterable(): boolean {\n    return false\n  }\n}\n\nconst ITERABLE_DATATYPES = [\n  \"concept-list\",\n  \"resource-instance-list\",\n  \"domain-value-list\"\n];\n\nclass PseudoValue<VM extends IViewModel> implements IPseudo {\n  node: StaticNode;\n  tile: StaticTile | null;\n  value: any;\n  parent: IRIVM<any> | null;\n  parentNode: PseudoValue<any> | null;\n  valueLoaded: boolean | undefined = false;\n  datatype: string | null = null;\n  originalTile: StaticTile | null;\n  accessed: boolean;\n  childNodes: Map<string, StaticNode>;\n  isOuter: boolean = false;\n  isInner: boolean = false;\n  inner: PseudoValue<ISemantic> | null = null;\n  independent: boolean;\n\n  isIterable(): boolean {\n    return this.datatype !== null && ITERABLE_DATATYPES.includes(this.datatype);\n  }\n\n  describeField() {\n    let fieldName = this.node.name;\n    if (this.parent && this.parent.__) {\n      fieldName = `${this.parent.__.wkrm.modelName} - ${fieldName}`;\n    }\n    return fieldName;\n  }\n\n  describeFieldGroup() {\n    let fieldName = this.node.name;\n    if (this.parent && this.node.nodegroup_id && this.parent.$) {\n      const nodegroup = this.parent.$.model.getNodeObjects().get(this.node.nodegroup_id);\n      if (nodegroup && this.parent.__) {\n        fieldName = `${this.parent.__.wkrm.modelName} - ${nodegroup.name}`;\n      }\n    }\n    return fieldName;\n  }\n\n  constructor(\n    node: StaticNode,\n    tile: StaticTile | null,\n    value: any,\n    parent: IRIVM<any> | null,\n    childNodes: Map<string, StaticNode>,\n    inner: boolean | PseudoValue<ISemantic>,\n  ) {\n    this.node = node;\n    this.tile = tile;\n    this.independent = tile === null;\n    if (!parent) {\n      throw Error(\"Must have a parent or parent class for a pseudo-node\");\n    }\n    this.parent = parent;\n    this.parentNode = null;\n    this.childNodes = childNodes;\n    this.value = value;\n    this.accessed = false;\n    this.originalTile = tile;\n    this.datatype = node.datatype;\n    if (inner instanceof PseudoValue) {\n      this.isOuter = true;\n      this.inner = inner;\n    }\n    if (inner === true) {\n      this.isInner = true;\n      this.datatype = 'semantic';\n    }\n  }\n\n  // TODO deepcopy\n  //\n\n  getParentTileId() {\n    return this.tile ? this.tile.parenttile_id : null;\n  }\n\n  async getTile(): Promise<[StaticTile | null, any[]]> {\n    await this.updateValue();\n\n    let relationships: Array<any> = [];\n\n    if (this.inner) {\n      this.tile, relationships = await this.inner.getTile();\n    }\n\n    let tileValue;\n    if (this.value !== null) {\n      // It may be better to make this fully async if there's a performance benefit.\n      let [newTileValue, ownRelationships] = await (await this.value).__asTileData();\n      tileValue = newTileValue;\n      relationships = [...relationships, ...ownRelationships];\n    } else {\n      tileValue = null;\n    }\n    // if isinstance(tile_value, tuple):\n    //     relationships = [\n    //         relationship\n    //         if isinstance(relationship, tuple)\n    //         else (self.tile.nodegroup_id, self.node.nodeid, relationship)\n    //         for relationship in tile_value[1]\n    //     ]\n    //     tile_value = tile_value[0]\n    if (!this.tile) {\n      throw Error();\n    }\n    this.tile.data = this.tile.data || {};\n    if (tileValue === null) {\n      if (this.tile.data.get(this.node.nodeid)) {\n        this.tile.data.delete(this.node.nodeid);\n      }\n    } else {\n      this.tile.data.set(this.node.nodeid, tileValue);\n    }\n    const tile = this.independent ? this.tile : null;\n\n    // TODO relationships\n    return [tile, relationships];\n  }\n\n  clear() {\n    this.value = null;\n    if (this.tile && this.tile.data && this.tile.data.has(this.node.nodeid)) {\n      this.tile.data.delete(this.node.nodeid);\n    }\n  }\n\n  updateValue(tile?: StaticTile | null): AttrPromise<VM> {\n    if (tile) {\n      this.tile = tile;\n    }\n    this.accessed = true;\n    if (this.inner) {\n      this.inner.accessed = true;\n    }\n    if (!this.tile) {\n      if (!this.node) {\n        throw Error(\"Empty tile\");\n      }\n      if (this.inner) {\n        return new AttrPromise(async (resolve) => {\n          const tile = await this.inner?.getTile();\n          resolve(this.updateValue(tile ? tile[0] : undefined));\n        });\n      }\n      if (!this.tile) {\n        // NB: You may see issues where the nodegroup is null because it is the root node,\n        // and a node below is not marked as a collector, so tries to fill its tile in\n        // A cardinality n node below the root should be a collector.\n        this.tile = new StaticTile({\n          nodegroup_id: this.node.nodegroup_id || \"\",\n          tileid: null,\n          data: new Map<string, any>(),\n          sortorder: this.node.sortorder,\n          resourceinstance_id: \"\",\n          parenttile_id: null,\n          provisionaledits: null,\n          ensureId: () => \"\"\n        });\n        // this.relationships = [];\n      }\n    }\n    if (this.valueLoaded === false) {\n      this.valueLoaded = undefined;\n      let data: any;\n      if (\n        this.value === null &&\n        this.tile.data !== null &&\n        this.tile.data.has(this.node.nodeid) &&\n        this.datatype !== 'semantic' // Semantic nodes only have placeholder data\n      ) {\n        data = this.tile.data.get(this.node.nodeid);\n      } else {\n        data = this.value;\n      }\n\n      if (this.isOuter && typeof data === 'object' && this.inner && data) {\n        let outerData = undefined;\n        if (\"_\" in data && !data.constructor) {\n          outerData = data[\"_\"];\n          delete data[\"_\"];\n          this.inner.getValue().then((v: ISemantic | null) => v && v.update(data));\n          data = outerData;\n        } else if (data instanceof Map && data.has(\"_\")) {\n          outerData = data.get(\"_\");\n          data.delete(\"_\");\n          this.inner.getValue().then((v: ISemantic | null) => v && v.update(data));\n          data = outerData;\n        }\n      }\n      const vm = getViewModel(\n        this,\n        this.tile,\n        this.node,\n        data,\n        this.parent,\n        this.childNodes,\n        this.isInner\n      );\n\n      const resolveAttr = (vm: IViewModel) => {\n        if (vm !== null && vm instanceof Object) {\n          vm.__parentPseudo = this;\n          if (this.isOuter && this.inner) {\n            vm._ = this.inner.getValue();\n          }\n\n          this.valueLoaded = true;\n        }\n        return vm;\n      };\n      this.value = new AttrPromise((resolve) => {\n        vm.then((vm) => resolve(vm ? resolveAttr(vm) : vm));\n      });\n    }\n\n    return this.value;\n  }\n\n  public getValue(): AttrPromise<VM | null> {\n    return this.updateValue();\n  }\n\n  // @value.setter\n  // def value(this, value):\n\n  getLength() {\n    return this.getChildren().length;\n  }\n\n  async getChildTypes() {\n    await this.updateValue();\n    let childTypes = {};\n    if (this.value instanceof Object) {\n      try {\n        childTypes = this.value.getChildTypes();\n      } catch (AttributeError) {}\n    }\n    if (this.inner) {\n      Object.assign(childTypes, this.inner.getChildTypes());\n    }\n    return childTypes;\n  }\n\n  getChildren(direct = null): IPseudo[] {\n    let children = [];\n    if (this.value) {\n      try {\n        children = this.value.getChildren(direct);\n      } catch (AttributeError) {}\n    }\n    if (this.inner) {\n      children = [...children, ...this.inner.getChildren(direct)];\n    }\n    return children;\n  }\n\n  async forJson(): Promise<{[key: string]: any} | {[key: string]: any}[] | string | number | boolean | null> {\n    const value = (await this.getValue());\n    return value instanceof Object ? value.forJson() : value;\n  }\n}\n\nclass PseudoList extends Array implements IPseudo {\n  node: StaticNode | undefined = undefined;\n  parent: IRIVM<any> | null | undefined = undefined;\n  parentNode: PseudoValue<any> | null = null;\n  tile: StaticTile | undefined;\n  parenttileId: string | undefined;\n  ghostChildren: Set<PseudoValue<any>> | null = null;\n  isOuter: boolean = false;\n\n  isIterable(): boolean {\n    return true;\n  }\n\n  async sorted() {\n    const resolved = await Promise.all(this.map(async (pn) => await pn));\n    const test = [];\n    const sorted = resolved.sort((a, b) => {\n      const vals = [a, b].map(val => {\n        if (val && a.__parentPseudo && a.__parentPseudo.tile) {\n          if (val.__parentPseudo.tile.sortorder > 0) {\n            // RMV\n            test.push(1);\n          }\n          return val.__parentPseudo.tile.sortorder;\n        } else {\n          return 0;\n        }\n      });\n      return vals[0] - vals[1];\n    });\n    return sorted;\n  }\n\n  describeField() {\n    if (!this.node) {\n      return \"[(uninitialized node)]\";\n    }\n\n    let fieldName = this.node.name;\n    if (this.parent && this.parent.__) {\n      fieldName = `${this.parent.__.wkrm.modelName} - ${fieldName}`;\n    }\n    return `[${fieldName}]`;\n  }\n\n  describeFieldGroup() {\n    if (!this.node) {\n      return \"[(uninitialized node)]\";\n    }\n\n    let fieldName = this.node.name;\n    if (this.parent && this.node.nodegroup_id && this.parent.$) {\n      const nodegroup = this.parent.$.model.getNodeObjects().get(this.node.nodegroup_id);\n      if (nodegroup && this.parent.__) {\n        fieldName = `${this.parent.__.wkrm.modelName} - ${nodegroup.name}`;\n      }\n    }\n    return `[${fieldName}]`;\n  }\n\n  // Otherwise interferes with Array methods;\n  initialize(node: StaticNode, parent: IRIVM<any> | null) {\n    this.node = node;\n    if (Array.isArray(this.node)) {\n      throw Error(\"Cannot make a list of lists\");\n    }\n    if (!parent) {\n      throw Error(\"Must have a parent or parent class for a pseudo-node\");\n    }\n    this.parent = parent;\n    this.tile = undefined;\n    this.parenttileId = undefined;\n    this.ghostChildren = new Set();\n  }\n\n  async forJson(): Promise<{[key: string]: any}[]> {\n    const array: {[key: string]: any}[] = Array.from(\n      (await this.sorted()).map(\n        async (entry: Promise<IViewModel> | IViewModel) => {\n          const value = await entry;\n          return (value && value instanceof Object && value.forJson) ? value.forJson() : value;\n        }\n      )\n    );\n    return Promise.all(array);\n  }\n\n  getValue(): AttrPromise<PseudoList> {\n    return new AttrPromise(resolve => resolve(this));\n  }\n\n  toString() {\n    return `<PL: ${this.length}>`;\n  }\n}\n\n// Fix wkri type.\nfunction makePseudoCls(\n  model: IModelWrapper<any>,\n  key: string,\n  single: boolean,\n  tile: StaticTile | null = null,\n  wkri: any | null = null,\n): PseudoList | PseudoValue<any> | PseudoUnavailable {\n  const nodeObjs = model.getNodeObjectsByAlias();\n  const nodeObj = nodeObjs.get(key);\n  if (!nodeObj) {\n    throw Error(\"Could not find node by alias\");\n  }\n\n  const nodegroups = model.getNodegroupObjects();\n  const nodegroup = nodegroups.get(nodeObj.nodegroup_id || \"\");\n\n  let value = null;\n  if (\n    nodeObj.nodegroup_id &&\n    nodeObj.is_collector &&\n    nodegroup &&\n    nodegroup.cardinality == \"n\" &&\n    !single\n  ) {\n    value = new PseudoList();\n    value.initialize(nodeObj, wkri);\n  }\n  if (value === null || tile) {\n    let nodeValue;\n    const isPermitted = model.isNodegroupPermitted(nodeObj.nodegroup_id || '', tile, nodeObjs);\n    if (isPermitted) {\n      const childNodes: Map<string, StaticNode> = model.getChildNodes(nodeObj.nodeid);\n      let inner: boolean | PseudoValue<any> = false;\n      if (childNodes && childNodes.size && nodeObj.datatype !== 'semantic') {\n        inner = new PseudoValue(nodeObj, tile, null, wkri, childNodes, true);\n      }\n      nodeValue = new PseudoValue(nodeObj, tile, null, wkri, inner !== false ? new Map() : childNodes, inner);\n    } else {\n      nodeValue = new PseudoUnavailable(nodeObj);\n    }\n    // If we have a tile in a list, add it\n    if (value) {\n      value.push(nodeValue.getValue());\n    } else {\n      value = nodeValue;\n    }\n  }\n\n  return value;\n}\n\nexport { PseudoValue, PseudoList, PseudoUnavailable, makePseudoCls };\n","import { GraphResult, archesClient, ArchesClient, ArchesClientRemote } from \"./client.ts\";\nimport { staticStore } from \"./staticStore.ts\"\nimport {\n  StaticCard,\n  StaticEdge,\n  StaticCardsXNodesXWidgets,\n  StaticFunctionsXGraphs,\n  StaticTile,\n  StaticGraph,\n  StaticNode,\n  StaticNodegroup,\n  StaticResource,\n  StaticResourceDescriptors,\n  StaticGraphMeta,\n} from \"./static-types\";\nimport { makePseudoCls, PseudoList } from \"./pseudos.ts\";\nimport { DEFAULT_LANGUAGE, ResourceInstanceViewModel, ValueList, viewContext, SemanticViewModel } from \"./viewModels.ts\";\nimport { CheckPermission, GetMeta, IRIVM, IStringKeyedObject, IPseudo, IInstanceWrapper, IViewModel, ResourceInstanceViewModelConstructor } from \"./interfaces\";\nimport { AttrPromise } from \"./utils\";\n\nconst MAX_GRAPH_DEPTH = 100;\nconst DESCRIPTOR_FUNCTION_ID = \"60000000-0000-0000-0000-000000000001\";\n\nclass WKRM {\n  modelName: string;\n  modelClassName: string;\n  graphId: string;\n  meta: StaticGraphMeta;\n\n  constructor(meta: StaticGraphMeta) {\n    let name: {[lang: string]: string} | string | undefined;\n    if (meta.name instanceof Object) {\n      name = meta.name[DEFAULT_LANGUAGE].toString();\n    } else {\n      name = meta.name;\n    }\n    this.modelName = name || \"Unnamed\";\n    this.graphId = meta.graphid;\n    this.modelClassName = (meta.slug || this.modelName)\n      .replace(/[_-]/g, \" \")\n      .replace(/\\s(.)/g, (c: string) => c.toUpperCase())\n      .replace(/\\s/g, \"\");\n    this.modelClassName = this.modelClassName[0].toUpperCase() + this.modelClassName.slice(1);\n    this.meta = meta;\n  }\n}\n\nclass ConfigurationOptions {\n  graphs: Array<string> | null | boolean;\n\n  constructor() {\n    this.graphs = null;\n  }\n}\n\nclass ResourceInstanceWrapper<RIVM extends IRIVM<RIVM>> implements IInstanceWrapper<RIVM> {\n  wkri: RIVM;\n  model: ResourceModelWrapper<RIVM>;\n\n  resource: StaticResource | null | false ;\n  valueList: ValueList<RIVM>;\n  cache: {[tileId: string]: {[nodeId: string]: IStringKeyedObject}} | undefined;\n  scopes?: string[];\n  metadata?: {[key: string]: string};\n\n  constructor(\n    wkri: RIVM,\n    model: ResourceModelWrapper<RIVM>,\n    resource: StaticResource | null | false, // False to disable dynamic resource-loading\n  ) {\n    this.wkri = wkri;\n    this.model = model;\n    if (resource) {\n      this.model.stripTiles(resource);\n    }\n    this.resource = resource;\n    this.valueList = new ValueList(new Map<string, any>(), new Map<string, boolean>(), this, []);\n    this.cache = resource ? resource.__cache : undefined;\n    this.scopes = resource ? resource.__scopes : undefined;\n    this.metadata = resource ? resource.metadata : undefined;\n  }\n\n  async loadNodes(aliases: Array<string>): Promise<void> {\n    for (const key of aliases) {\n      await this.valueList.retrieve(key);\n    }\n  }\n\n  async getName(update: boolean = false) {\n    let resourceName = this.resource && this.resource.resourceinstance.name;\n    if (update || !resourceName) {\n      const descriptors = await this.getDescriptors(update);\n      resourceName = (descriptors && descriptors.name) || resourceName || '<Unnamed>';\n      if (this.resource && this.resource.resourceinstance) {\n        this.resource.resourceinstance.name = resourceName;\n      }\n    }\n    return resourceName;\n  }\n\n  async getDescriptors(update: boolean = false) {\n    let descriptors = this.resource && this.resource.resourceinstance.descriptors;\n    if (update || !descriptors || descriptors.isEmpty()) {\n      descriptors = new StaticResourceDescriptors();\n      let descriptorConfig;\n      if (this.model.graph.functions_x_graphs) {\n        const descriptorNode = this.model.graph.functions_x_graphs.find(node => node.function_id === DESCRIPTOR_FUNCTION_ID);\n        if (descriptorNode) {\n          descriptorConfig = descriptorNode.config;\n        }\n      }\n      const nodes = this.model.getNodeObjects();\n      if (descriptorConfig) {\n        for (const [descriptor, config] of Object.entries(descriptorConfig.descriptor_types)) {\n          const semanticNode = nodes.get(config.nodegroup_id);\n          let description = config.string_template;\n          if (!description) {\n            continue;\n          }\n          const requestedNodes = [...description.match(/<[A-Za-z _-]*>/g)];\n          const relevantNodes = [...nodes.values()].filter(node => node.nodegroup_id === config.nodegroup_id && requestedNodes.includes(`<${node.name}>`)).map(node => [node.name, node.alias || '']);\n          let relevantValues;\n          // First try and see if we can find all of these on one tile, for consistency.\n          if (semanticNode) {\n            let semanticValue = await (await this.valueList.retrieve(semanticNode.alias || ''))[0];\n            if (semanticValue instanceof PseudoList) {\n              semanticValue = await semanticValue[0];\n            }\n            if (semanticValue) {\n              semanticValue = await semanticValue.getValue();\n              if (semanticValue) {\n                relevantValues = await Promise.all(relevantNodes.filter(([_, alias]) => semanticValue.__has(alias)).map(([name, alias]) => semanticValue[alias].then((value: IViewModel) => [name, value])));\n              }\n            }\n          }\n          if (relevantValues) {\n            description = relevantValues.reduce((desc, [name, value]) => value ? desc.replace(`<${name}>`, value) : desc, description);\n          }\n          relevantValues = await Promise.all(relevantNodes.map(([name, alias]) => this.valueList.retrieve(alias).then(values => [name, values ? values[0] : undefined])));\n          if (relevantValues) {\n            description = relevantValues.reduce((desc, [name, value]) => value ? desc.replace(`<${name}>`, value) : desc, description);\n          }\n          descriptors[descriptor] = description;\n        }\n      }\n    }\n    if (this.resource && this.resource.resourceinstance) {\n      this.resource.resourceinstance.descriptors = descriptors;\n      if (descriptors.name) {\n        this.resource.resourceinstance.descriptors.name = descriptors.name;\n      }\n    }\n    return descriptors;\n  }\n\n  addPseudo(childNode: StaticNode, tile: StaticTile | null, node: StaticNode): IPseudo {\n    const key = childNode.alias;\n    if (!key) {\n      throw Error(`Cannot add a pseudo node with no alias ${childNode.nodeid}`);\n    }\n    const child = makePseudoCls(\n      this.model,\n      key,\n      false,\n      (!childNode.is_collector && childNode.nodegroup_id === node.nodegroup_id) ? tile : null, // Does it share a tile\n      this.wkri,\n    );\n\n    const valueList: ValueList<any> = this.valueList;\n    valueList.setDefault(key, []).then((val: Array<any>) => val.push(child));\n    return child;\n  }\n\n  allEntries(): MapIterator<[string, Array<IPseudo> | false | null]> {\n    return this.valueList.values.entries()\n  }\n\n  async keys() {\n    return (await this.getRootViewModel()).keys();\n  }\n\n  async values() {\n    return (await this.getRootViewModel()).values();\n  }\n\n  async entries() {\n    return (await this.getRootViewModel()).entries();\n  }\n\n  async getRootViewModel(): Promise<SemanticViewModel> {\n    const root = await this.getRoot();\n    let value: IViewModel | null = null;\n    if (root) {\n      const rootValue = await root.getValue();\n      if (!Array.isArray(rootValue)) {\n        value = rootValue;\n      }\n    }\n    if (!value || !(value instanceof SemanticViewModel)) {\n      throw Error(`Tried to get root on ${this}, which has no root`);\n    }\n    return value;\n  }\n\n  getOrmAttribute(key: string): AttrPromise<IViewModel> {\n    let promise: Promise<void>;\n    if (this.resource === null) {\n      promise = this.model.findStatic(this.wkri.id).then(resource => {\n        this.resource = resource;\n      }).then(() => this.populate(true));\n    } else {\n      promise = new Promise((resolve) => { resolve(); });\n    }\n\n    // TODO remapping\n    return promise.then(() => this.getRootViewModel()).then(root => root[key]);\n  }\n\n  async getRoot(): Promise<IPseudo | undefined> {\n    const values = this.valueList;\n    const node = this.model.getRootNode();\n    if (node) {\n      let value;\n      const alias = node.alias;\n      if (!(typeof alias == 'string')) {\n        throw Error(`Alias missing for node ${node.nodeid}`);\n      }\n      await values.setDefault(alias, []);\n      const nodeValues = await values.get(alias);\n\n      if (nodeValues.length > 1) {\n        throw Error(\"Cannot have multiple root tiles\");\n      } else if (nodeValues.length == 1) {\n        value = nodeValues[0];\n      } else {\n        value = makePseudoCls(this.model, alias, false, null, this.wkri);\n        values.set(alias, [value]);\n      }\n      return value;\n    }\n  }\n\n  setOrmAttribute(key: string, value: any) {\n    // TODO remapping\n    return this.getRootViewModel().then((root) => {\n      if (root) {\n        root[key] = value;\n      } else {\n        throw Error(`Tried to set ${key} on ${self}, which has no root`);\n      }\n    });\n  }\n\n  async ensureNodegroup(\n    allValues: Map<string, any>,\n    allNodegroups: Map<string, boolean | Promise<any>>,\n    nodegroupId: string,\n    nodeObjs: Map<string, StaticNode>,\n    nodegroupObjs: Map<string, StaticNodegroup>,\n    edges: Map<string, string[]>,\n    addIfMissing: boolean,\n    tiles: StaticTile[] | null,\n    doImpliedNodegroups: boolean = true\n  ): Promise<[Map<string, any>, Set<string>]> {\n    const impliedNodegroups: Set<string> = new Set();\n    const sentinel = allNodegroups.get(nodegroupId); // no action required if pending\n    let newValues = new Map();\n\n    if (sentinel === false || (addIfMissing && sentinel === undefined)) {\n      [...nodeObjs.values()].filter((node: StaticNode) => {\n        return node.nodegroup_id === nodegroupId;\n      }).forEach((node: StaticNode) => allValues.delete(node.alias || ''));\n      let nodegroupTiles: (StaticTile | null)[];\n      if (tiles === null) {\n        nodegroupTiles = [];\n        console.error(\"Tiles must be provided and cannot be lazy-loaded yet\");\n      } else {\n        nodegroupTiles = tiles.filter(\n          (tile) => tile.nodegroup_id == nodegroupId && this.model.isNodegroupPermitted(nodegroupId, tile)\n        );\n        if (nodegroupTiles.length == 0 && addIfMissing) {\n          nodegroupTiles = [null];\n        }\n        const rgValues = await this.valuesFromResourceNodegroup(\n          allValues,\n          nodegroupTiles,\n          nodegroupId,\n          nodeObjs,\n          edges,\n        );\n        newValues = rgValues[0];\n        const newImpliedNodegroups: Set<string> = rgValues[1];\n\n        [...newValues.entries()].forEach((entry) => {\n          if (entry[1] !== undefined) {\n            allValues.set(entry[0], entry[1]);\n          }\n        });\n        [...newImpliedNodegroups].forEach((v) => {\n          impliedNodegroups.add(v);\n        });\n        allNodegroups.set(nodegroupId, true);\n      }\n    }\n\n    // RMV double-check against Python logic\n    if (doImpliedNodegroups) {\n      for (const nodegroupId of [...impliedNodegroups]) {\n        // TODO: why are we not keeping implied nodegroups?\n        const [impliedValues] = await this.ensureNodegroup(\n          allValues,\n          allNodegroups,\n          nodegroupId,\n          nodeObjs,\n          nodegroupObjs,\n          edges,\n          true,\n          tiles, // RMV different from Python\n          true\n        );\n        for (const [key, value] of impliedValues) {\n          newValues.set(key, value);\n        }\n      }\n      impliedNodegroups.clear();\n    }\n\n    return [newValues, impliedNodegroups];\n  }\n\n  async populate(lazy: boolean): Promise<void> {\n    const nodeObjs = this.model.getNodeObjects();\n    const nodegroupObjs = this.model.getNodegroupObjects();\n    const edges = this.model.getEdges();\n    // FIXME: this needs to be nodeObjs to ensure tiles\n    // whose nodegroup node is in a different nodegroup\n    // (e.g. children of designation_and_protection_timespan)\n    // get loaded - however, just doing that drops performance\n    // by half or two-thirds, so a less wasteful approach is needed.\n    const allValues: Map<string, any> = new Map();\n    const allNodegroups: Map<string, any> = new Map([...nodegroupObjs.keys()].map((id: string) => {\n      return [id || \"\", false];\n    }));\n    //[...nodegroupObjs.keys()].map((id: string) => {\n    //  const node = nodeObjs.get(id);\n    //  if (!node) {\n    //    throw Error(`Could not find node for nodegroup ${id}`);\n    //  }\n    //  allValues.set(node.alias || \"\", false);\n    //});\n    const rootNode = this.model.getRootNode();\n\n    if (rootNode.alias === null) {\n      throw Error(\"Cannot populate a model with no proper root node\");\n    }\n\n    allValues.set(rootNode.alias, false);\n\n    let tiles = null;\n    if (!lazy && this.resource) {\n      tiles = this.resource.tiles;\n      let impliedNodegroups = new Set<string>();\n      for (const [ng] of nodegroupObjs) {\n        const [_, newImpliedNodegroups] = await this.ensureNodegroup(\n          allValues,\n          allNodegroups,\n          ng,\n          nodeObjs,\n          nodegroupObjs,\n          edges,\n          true, // RMV: check vs python\n          tiles,\n          false\n        );\n\n        for (const impliedNodegroup of [...newImpliedNodegroups]) {\n          impliedNodegroups.add(impliedNodegroup);\n        }\n        impliedNodegroups.delete(ng);\n      }\n\n      while (impliedNodegroups.size) {\n        const newImpliedNodegroups = new Set<string>();\n        for (const nodegroupId of [...impliedNodegroups]) {\n          const currentValue = allNodegroups.get(nodegroupId);\n          if (currentValue === false || currentValue === undefined) {\n            const [_, newImpliedNodegroups] = await this.ensureNodegroup(\n              allValues,\n              allNodegroups,\n              nodegroupId,\n              nodeObjs,\n              nodegroupObjs,\n              edges,\n              true,\n              tiles, // RMV different from Python\n              true\n            );\n            for (const impliedNodegroup of [...newImpliedNodegroups]) {\n              newImpliedNodegroups.add(impliedNodegroup);\n            }\n          }\n        }\n        impliedNodegroups = newImpliedNodegroups;\n      }\n    } else if (this.resource) {\n      this.model.stripTiles(this.resource);\n    }\n\n    this.valueList = new ValueList(\n      allValues,\n      allNodegroups,\n      this,\n      this.resource ? this.resource.tiles : null,\n    );\n  }\n\n  async getValueCache(build: boolean = true, getMeta: GetMeta = undefined): Promise<{[tileId: string]: {[nodeId: string]: IStringKeyedObject}} | undefined> {\n    if (build) {\n      this.cache = await this.buildValueCache(getMeta);\n    }\n    return this.cache;\n  }\n\n  async buildValueCache(getMeta: GetMeta): Promise<{[tileId: string]: {[nodeId: string]: IStringKeyedObject}}> {\n    const cacheByTile: {[tileId: string]: {[nodeId: string]: IStringKeyedObject}} = {};\n    for (let pseudos of this.valueList.values.values()) {\n      pseudos = await pseudos;\n      if (pseudos) {\n        await Promise.all(pseudos.map(async (pseudo: IPseudo) => {\n          const value = await pseudo.getValue();\n          // We do not try to cache pseudolists\n          if (pseudo.tile && value && (!Array.isArray(pseudo))) {\n            // @ts-expect-error this can be IViewModel[] while using a pseudolist\n            const cacheJson = await value.__forJsonCache(getMeta); // caching JSON\n            if (cacheJson) {\n              const tileId = pseudo.tile.ensureId();\n              const nodeId = pseudo.node.nodeid;\n              if (!(tileId in cacheByTile)) {\n                cacheByTile[tileId] = {};\n              }\n              if (!(nodeId in cacheByTile[tileId])) {\n                cacheByTile[tileId][nodeId] = {};\n              }\n              cacheByTile[tileId][nodeId] = cacheJson;\n            }\n          }\n        }));\n      }\n    }\n    return cacheByTile;\n  }\n\n  async valuesFromResourceNodegroup(\n    existingValues: Map<string, any>,\n    nodegroupTiles: (StaticTile | null)[],\n    nodegroupId: string,\n    nodeObjs: Map<string, StaticNode>,\n    edges: Map<string, string[]>,\n  ): Promise<[Map<string, any>, Set<string>]> {\n    const allValues = new Map<string, any>();\n\n    const impliedNodegroups = new Set<string>();\n    const impliedNodes: Map<string, [StaticNode, StaticTile]> = new Map();\n\n    const nodesUnseen = new Set(\n      [...nodeObjs.values()]\n        .filter((node) => node.nodegroup_id == nodegroupId)\n        .map((node) => node.alias),\n    );\n    const tileNodesSeen: Set<[string, string]> = new Set();\n    const _addPseudo = async (node: StaticNode, tile: StaticTile | null) => {\n      const key = node.alias || \"\";\n      nodesUnseen.delete(node.alias);\n      const tileid = tile && tile.tileid;\n      if (tileid) {\n        tileNodesSeen.add([node.nodeid, tileid]);\n      }\n      let existing = existingValues.get(key);\n      if (existing instanceof Promise) {\n        existing = await existing;\n      }\n      if (existing !== false && existing !== undefined) {\n        // This might be correct - confirm.\n        // console.warn(`Tried to load node twice: ${key} (${node.nodeid}<${node.nodegroup_id})`, nodegroupId);\n        allValues.set(key, existing);\n      }\n      if (!allValues.has(key)) {\n        allValues.set(key, []);\n      }\n      const pseudoNode = makePseudoCls(this.model, key, false, tile, this.wkri);\n      // We shouldn't have to take care of this case, as it should already\n      // be included below.\n      // if tile.parenttile_id:\n      for (const [domain, ranges] of edges) {\n        if (ranges.includes(node.nodeid)) {\n          const domainNode = nodeObjs.get(domain);\n          if (!domainNode) {\n            throw Error(\"Edge error in graph\");\n          }\n          const toAdd = domainNode.nodegroup_id\n            ? domainNode.nodegroup_id\n            : '';\n          if (toAdd && toAdd !== nodegroupId) {\n            impliedNodegroups.add(toAdd);\n          }\n          if (domainNode.nodegroup_id && tile && domainNode.nodegroup_id === tile.nodegroup_id && domainNode.nodegroup_id !== domainNode.nodeid && tileid && !impliedNodes.has(domainNode.nodeid + tileid)) {\n            impliedNodes.set(domainNode.nodeid + tileid, [domainNode, tile]);\n          }\n          break;\n        }\n      }\n      if (Array.isArray(pseudoNode)) {\n        const value = allValues.get(key);\n        if (value !== undefined && value !== false) {\n          for (const pseudoList of allValues.get(key)) {\n            if (!(pseudoList instanceof PseudoList) || !(pseudoNode instanceof PseudoList)) {\n              throw Error(`Should be all lists not ${typeof pseudoList} and ${typeof pseudoNode}`);\n            }\n\n            if (pseudoList.parentNode == pseudoNode.parentNode) {\n              for (const ps of pseudoNode) {\n                pseudoList.push(ps);\n              }\n              return;\n            }\n          }\n        }\n      }\n      allValues.get(key).push(pseudoNode);\n    };\n\n    for (const tile of nodegroupTiles) {\n      const parentNode = nodeObjs.get(nodegroupId);\n      if (parentNode === undefined) {\n        continue;\n      }\n      if (!parentNode.nodegroup_id || parentNode.nodegroup_id == nodegroupId) {\n        await _addPseudo(parentNode, tile);\n      }\n\n      if (tile) {\n        const tileNodes = new Map();\n        for (const [key, value] of [...tile.data.entries()]) {\n          tileNodes.set(key, value);\n        }\n\n        // Semantic nodes in this tile should always have a pseudo-node\n        [...nodeObjs.values()].filter((node: StaticNode) => {\n          return node.nodegroup_id === nodegroupId && !tileNodes.get(node.nodeid) && node.datatype === 'semantic';\n        }).forEach((node: StaticNode) => tileNodes.set(node.nodeid, {}));\n\n        if (!tileNodes.has(tile.nodegroup_id)) {\n          tileNodes.set(tile.nodegroup_id, {});\n        }\n        for (const [nodeid, nodeValue] of [...tileNodes.entries()]) {\n          if (nodeid == nodegroupId) {\n            // RMV is this correct?\n            continue;\n          }\n          const node = nodeObjs.get(nodeid);\n          if (!node) {\n            throw Error(`Unknown node in nodegroup: ${nodeid} in ${nodegroupId}`);\n          }\n          if (nodeValue !== null) {\n            await _addPseudo(node, tile);\n          }\n        }\n      }\n    }\n    while (impliedNodes.size > 0) {\n      const value = impliedNodes.entries().next().value;\n      if (value) {\n        const [node, tile] = value[1];\n        // If nodeid!=nodegroup_id, then it has its own tile.\n        if (tile.tileid && !tileNodesSeen.has([node.nodeid, tile.tileid])) {\n          await _addPseudo(node, tile);\n        }\n        impliedNodes.delete(value[0]);\n      }\n    }\n    // Remove any \"unloaded\" sentinel values so we do not try and\n    // reload this nodegroup.\n    [...nodesUnseen.keys()].forEach((nodeUnseen) => {\n      // if (allValues.get(nodeUnseen) === false) { // TODO: work out why this is not necessary\n      if (nodeUnseen) {\n        allValues.set(nodeUnseen, undefined);\n      }\n      // }\n    });\n    return [allValues, impliedNodegroups];\n  }\n}\n\nclass ResourceModelWrapper<RIVM extends IRIVM<RIVM>> {\n  wkrm: WKRM;\n  graph: StaticGraph;\n  viewModelClass?: ResourceInstanceViewModelConstructor<RIVM>;\n  permittedNodegroups?: Map<string | null, boolean | CheckPermission>;\n\n  constructor(wkrm: WKRM, graph: StaticGraph, viewModelClass?: ResourceInstanceViewModelConstructor<RIVM>) {\n    this.wkrm = wkrm;\n    this.graph = graph;\n    this.viewModelClass = viewModelClass;\n  }\n\n  // TODO: Switch to getBranches\n  getBranchPublicationIds(accessible?: boolean): string[] {\n    const accessibleOnly = accessible || false;\n    const nodes = [...this.graph.nodes.values()];\n    return [...nodes.reduce(\n      (acc: Set<string>, node: StaticNode): Set<string> => {\n        if (node.sourcebranchpublication_id) {\n          if (accessibleOnly) {\n            if (this.isNodegroupPermitted(node.nodegroup_id || '', null)) {\n              acc.add(node.sourcebranchpublication_id);\n            }\n          } else {\n            acc.add(node.sourcebranchpublication_id);\n          }\n        }\n        return acc;\n      }, new Set()\n    )];\n  }\n\n  getCollections(accessible?: boolean): string[] {\n    const accessibleOnly = accessible || false;\n    const nodes = [...this.graph.nodes.values()];\n    return [...nodes.reduce(\n      (acc: Set<string>, node: StaticNode): Set<string> => {\n        if (['concept', 'concept-list'].includes(node.datatype) && node.config?.rdmCollection) {\n          if (accessibleOnly) {\n            if (this.isNodegroupPermitted(node.nodegroup_id || '', null)) {\n              acc.add(node.config.rdmCollection);\n            }\n          } else {\n            acc.add(node.config.rdmCollection);\n          }\n        }\n        return acc;\n      }, new Set()\n    )];\n  }\n\n  pruneGraph(keepFunctions?: string[]): undefined {\n    const allNodegroups = this.getNodegroupObjects();\n    const root = this.graph.root.nodeid;\n    // Strictly, this ultimately also contains nodes, but not all allowed nodes - the key point is that\n    // it has only and all nodegroups that we will keep.\n    const allowedNodegroups = new Map([...allNodegroups.values()].filter((nodegroup: StaticNodegroup) => {\n      return this.isNodegroupPermitted(nodegroup.nodegroupid || '', null);\n    }).map((nodegroup: StaticNodegroup) => [nodegroup.nodegroupid, nodegroup.nodegroupid === null || nodegroup.nodegroupid === '' || nodegroup.nodegroupid === root]));\n    const backedges: Map<string, string> = new Map();\n    for (const [d, rs] of this.getEdges()) {\n      for (const r of rs) {\n        if (backedges.has(r)) {\n          throw Error(`Graph is malformed, node ${r} has multiple parents, ${backedges.get(r)} and ${d} at least`);\n        }\n        backedges.set(r, d);\n      }\n    }\n\n    let loops = 0;\n    // This is not a fast approach, but it's simple enough. Optimize if needed.\n    allowedNodegroups.set(root, true);\n    while (loops < MAX_GRAPH_DEPTH) {\n      const unrooted = [...allowedNodegroups.entries()].filter(([_, rooted]: [string, boolean]) => !rooted);\n      if (unrooted.length === 0) {\n        break;\n      }\n      for (const [ng] of unrooted) {\n        if (ng === root) {\n          continue;\n        }\n        const next = backedges.get(ng);\n        if (!next) {\n          throw Error(`Graph does not have a parent for ${ng}`);\n        }\n        allowedNodegroups.set(ng, true);\n        if (!allowedNodegroups.has(next)) {\n          allowedNodegroups.set(next, false);\n        }\n      }\n      loops += 1;\n    }\n\n    if (loops >= MAX_GRAPH_DEPTH) {\n      throw Error(\"Hit edge traversal limit when pruning, is the graph well-formed without cycles?\")\n    }\n\n    const allowedNodes = new Set([...this.getNodeObjects().values()].filter((node: StaticNode) => {\n      return (node.nodegroup_id && allowedNodegroups.get(node.nodegroup_id)) || node.nodeid === root;\n    }).map((node: StaticNode) => node.nodeid));\n\n    this.graph.cards = (this.graph.cards || []).filter((card: StaticCard) => allowedNodegroups.get(card.nodegroup_id));\n    this.graph.cards_x_nodes_x_widgets = (this.graph.cards_x_nodes_x_widgets || []).filter((card: StaticCardsXNodesXWidgets) => allowedNodes.has(card.node_id));\n    this.graph.edges = (this.graph.edges || []).filter((edge: StaticEdge) => (edge.domainnode_id === root || allowedNodes.has(edge.domainnode_id)) && allowedNodes.has(edge.rangenode_id));\n    this.graph.nodegroups = (this.graph.nodegroups || []).filter((ng: StaticNodegroup) => allowedNodegroups.has(ng.nodegroupid));\n    this.graph.nodes = (this.graph.nodes || []).filter((node: StaticNode) => allowedNodes.has(node.nodeid));\n\n    // At this point, every originally-allowed nodegroup has an allowed parent, up to the root.\n    if (Array.isArray(keepFunctions) && this.graph.functions_x_graphs) {\n      this.graph.functions_x_graphs = this.graph.functions_x_graphs.filter((fxg: StaticFunctionsXGraphs) => keepFunctions.includes(fxg.function_id));\n    } else {\n      this.graph.functions_x_graphs = [];\n    }\n  }\n\n  exportGraph(): StaticGraph {\n    const graph = this.graph;\n    return new StaticGraph({\n      author: graph.author,\n      cards: graph.cards,\n      cards_x_nodes_x_widgets: graph.cards_x_nodes_x_widgets,\n      color: graph.color,\n      config: graph.config,\n      deploymentdate: graph.deploymentdate,\n      deploymentfile: graph.deploymentfile,\n      description: graph.description,\n      edges: graph.edges,\n      functions_x_graphs: graph.functions_x_graphs,\n      graphid: graph.graphid,\n      iconclass: graph.iconclass,\n      is_editable: graph.is_editable,\n      isresource: graph.isresource,\n      jsonldcontext: graph.jsonldcontext,\n      name: graph.name,\n      nodegroups: graph.nodegroups,\n      nodes: graph.nodes,\n      ontology_id: graph.ontology_id,\n      publication: graph.publication,\n      relatable_resource_model_ids: graph.relatable_resource_model_ids,\n      resource_2_resource_constraints: graph.resource_2_resource_constraints,\n      root: graph.root,\n      slug: graph.slug,\n      subtitle: graph.subtitle,\n      template_id: graph.template_id,\n      version: graph.version,\n    });\n  }\n\n  async all(params: { limit?: number; lazy?: boolean } | undefined = undefined): Promise<Array<RIVM>> {\n    const paramObj = params || { limit: undefined, lazy: undefined };\n    const promises = [];\n    for await (const resource of this.iterAll(paramObj)) {\n      promises.push(resource);\n    }\n    return Promise.all(promises);\n  }\n\n  stripTiles(resource: StaticResource) {\n    if (resource.tiles) {\n      const nodes = this.getNodeObjects();\n      resource.tiles = resource.tiles.filter(tile => {\n        const node = nodes.get(tile.nodegroup_id);\n        if (!node) {\n          throw Error(`Tile ${tile.tileid} has nodegroup ${tile.nodegroup_id} that is not on the model ${this.graph.graphid}`);\n        }\n        return this.isNodegroupPermitted(tile.nodegroup_id || '', tile);\n      });\n    }\n  }\n\n  async* resourceGenerator(staticResources: AsyncIterable<StaticResource, RIVM, unknown>, lazy: boolean=false) {\n    for await (const staticResource of staticResources) {\n      yield this.fromStaticResource(staticResource, lazy);\n    }\n  }\n\n  async* iterAll(params: { limit?: number; lazy?: boolean }): AsyncGenerator<RIVM> {\n    yield* this.resourceGenerator(staticStore.loadAll(this.wkrm.graphId, params.limit), params.lazy);\n  }\n\n  async findStatic(id: string): Promise<StaticResource> {\n    return await staticStore.loadOne(id);\n  }\n\n  async find(id: string, lazy: boolean = true): Promise<RIVM> {\n    const rivm = await this.findStatic(id);\n    return this.fromStaticResource(rivm, lazy);\n  }\n\n  setPermittedNodegroups(permissions: Map<string | null, boolean | CheckPermission>) {\n    const nodegroups = this.getNodegroupObjects();\n    const nodes = this.getNodeObjectsByAlias();\n    const nodesById = this.getNodeObjects();\n    this.permittedNodegroups = new Map([...permissions].map(([key, value]): [key: string | null, value: boolean | CheckPermission] => {\n      const k = key || '';\n      if (nodegroups.has(k) || k === '') {\n        return [key, value];\n      } else {\n        const node = nodes.get(k);\n        if (node) {\n          // The nodeid is the nodegroup ID of the children, but may not be the nodegroup ID of\n          // the semantic node itself.\n          return [node.nodeid, value];\n        } else {\n          throw Error(`Could not find ${key} in nodegroups for permissions`);\n        }\n      }\n    }));\n  }\n\n  // Defaults to visible, which helps reduce the risk of false sense of security\n  // from front-end filtering masking the presence of data transferred to it.\n  getPermittedNodegroups(): Map<string | null, boolean | CheckPermission> {\n    if (!this.permittedNodegroups) {\n      const permissions = new Map([...this.getNodegroupObjects()].map(\n        ([k, _]: [k: string, _: StaticNodegroup]) => [k, true]\n      ));\n      permissions.set(\"\", true); // Have to have access to root node.\n      this.setPermittedNodegroups(permissions);\n    }\n    const permittedNodegroups = this.permittedNodegroups;\n    if (permittedNodegroups === undefined) {\n      throw Error(\"Could not set permitted nodegroups\");\n    }\n    // TODO allow reducing\n    return permittedNodegroups;\n  }\n\n  isNodegroupPermitted(nodegroupId: string, tile: StaticTile | null): boolean {\n    let permitted: boolean | CheckPermission | undefined = this.getPermittedNodegroups().get(nodegroupId);\n    if (permitted && typeof permitted == 'function') {\n      const nodes = this.getNodeObjectsByAlias();\n      permitted = permitted(nodegroupId, tile, nodes);\n    }\n    if (!permitted) {\n      return false;\n    }\n    if (permitted === true) {\n      return true;\n    }\n    throw Error(`Ambiguous permission state: ${permitted} for nodegroup ${nodegroupId}`);\n  }\n\n  makeInstance(id: string, resource: StaticResource | null): RIVM {\n    if (!this.viewModelClass) {\n      throw Error(`Cannot instantiate without a viewModelClass in ${this.wkrm.modelClassName}`);\n    }\n    // TODO: This line needs fixed.\n    const instance: RIVM = new this.viewModelClass(\n      id,\n      this.viewModelClass.prototype.__,\n      (rivm: RIVM) =>\n        new ResourceInstanceWrapper(rivm, this, resource),\n      null\n    );\n    return instance;\n  }\n\n  edges: Map<string, string[]> | undefined;\n  nodes: Map<string, StaticNode> | undefined;\n  nodegroups: Map<string, StaticNodegroup> | undefined;\n  nodesByAlias: Map<string, StaticNode> | undefined;\n\n  getChildNodes(nodeId: string): Map<string, StaticNode> {\n    const childNodes = new Map<string, StaticNode>();\n    const edges = this.getEdges().get(nodeId);\n    if (edges) {\n      for (const [, n] of this.getNodeObjects()) {\n        if (edges.includes(n.nodeid)) {\n          if (n.alias) {\n            childNodes.set(n.alias, n);\n          }\n        }\n      }\n    }\n    return childNodes;\n  }\n\n  buildNodes() {\n    if (this.nodes || this.nodegroups) {\n      throw Error(\"Cache should never try and rebuild nodes when non-empty\");\n    }\n\n    this.edges = new Map<string, string[]>();\n    this.nodes = new Map<string, StaticNode>();\n    this.nodegroups = new Map<string, StaticNodegroup>();\n\n    const graph = this.graph ?? graphManager.getGraph(this.wkrm.graphId);\n    if (!graph) {\n      throw Error(`Could not find graph ${this.wkrm.graphId} for resource`);\n    }\n    const nodes = new Map(graph.nodes.map((node) => [node.nodeid, node]));\n    const nodegroups = new Map(\n      graph.nodes\n        .filter((node) => node.nodegroup_id)\n        .map((node) => [\n          node.nodegroup_id || \"\",\n          new StaticNodegroup({\n            cardinality: \"n\",\n            legacygroupid: null,\n            nodegroupid: node.nodegroup_id || \"\",\n            parentnodegroup_id: null,\n          }),\n        ]),\n    );\n    for (const nodegroup of graph.nodegroups) {\n      nodegroups.set(nodegroup.nodegroupid, nodegroup);\n    }\n\n    const edgePairs = graph.edges.map((edge) => [\n      edge.domainnode_id,\n      edge.rangenode_id,\n    ]);\n    const edges: Map<string, string[]> = edgePairs.reduce((edges, dr) => {\n      const range = edges.get(dr[0]) || [];\n      range.push(dr[1]);\n      edges.set(dr[0], range);\n      return edges;\n    }, new Map<string, string[]>());\n\n    this.nodes = nodes;\n    this.nodegroups = nodegroups;\n    this.edges = edges;\n    this.nodesByAlias = new Map(\n      [...nodes.values()].map((node) => [node.alias || \"\", node]),\n    );\n  }\n\n  getNodeObjectsByAlias(): Map<string, StaticNode> {\n    if (!this.nodesByAlias) {\n      this.buildNodes();\n    }\n    if (!this.nodesByAlias) {\n      throw Error(\"Could not build nodes\");\n    }\n    return this.nodesByAlias;\n  }\n\n  getEdges(): Map<string, string[]> {\n    if (!this.edges) {\n      this.buildNodes();\n    }\n    if (!this.edges) {\n      throw Error(\"Could not build edges\");\n    }\n    return this.edges;\n  }\n\n  getNodeObjects(): Map<string, StaticNode> {\n    if (!this.nodes) {\n      this.buildNodes();\n    }\n    if (!this.nodes) {\n      throw Error(\"Could not build nodes\");\n    }\n    return this.nodes;\n  }\n\n  getNodegroupObjects(): Map<string, StaticNodegroup> {\n    if (!this.nodegroups) {\n      this.buildNodes();\n    }\n    if (!this.nodegroups) {\n      throw Error(\"Could not build nodegroups\");\n    }\n    return this.nodegroups;\n  }\n\n  getRootNode(): StaticNode {\n    const nodes = this.getNodeObjects();\n    const rootNode = [...nodes.values()].find((n) => !n.nodegroup_id);\n    if (!rootNode) {\n      throw Error(\n        `COULD NOT FIND ROOT NODE FOR ${this.wkrm.modelClassName}. Does the graph ${this.graph.graphid} still exist?`,\n      );\n    }\n    rootNode.alias = rootNode.alias || '';\n    return rootNode;\n  }\n\n  fromStaticResource(\n    resource: StaticResource,\n    lazy: boolean = false,\n  ): Promise<RIVM> {\n    // TODO: implement lazy\n    const wkri: RIVM = this.makeInstance(\n      resource.resourceinstance.resourceinstanceid,\n      resource,\n    );\n\n    if (!wkri.$) {\n      throw Error(\"Could not load resource from static definition\");\n    }\n\n    return wkri.$.populate(lazy).then(() => wkri);\n  }\n}\n\nfunction makeResourceModelWrapper<T extends IRIVM<T>>(\n  viewModelClass: ResourceInstanceViewModelConstructor<T> | undefined,\n  wkrm: WKRM,\n  graph: StaticGraph,\n): ResourceInstanceViewModelConstructor<T> {\n  let vmc: ResourceInstanceViewModelConstructor<T>;\n  if (!viewModelClass) {\n    // @ts-expect-error It may be possible to correct this, but TS does not know that\n    // the dynamically-defined class meets the IRIVM interface.\n    const viewModelClassObj: {[name: string]: ResourceInstanceViewModelConstructor<T>} = {\n      [wkrm.modelClassName]: class extends ResourceInstanceViewModel<T> {\n        static _: ResourceInstanceWrapper<T> | null;\n        static __: ResourceModelWrapper<T> | null;\n      },\n    };\n    vmc = viewModelClassObj[wkrm.modelClassName];\n  } else {\n    vmc = viewModelClass;\n  }\n\n  const wrapper = new ResourceModelWrapper<T>(wkrm, graph, vmc);\n  vmc.prototype.__ = wrapper;\n  return vmc;\n}\n\nclass GraphManager {\n  _initialized: boolean = false;\n  archesClient: ArchesClient;\n  graphs: Map<string, ResourceModelWrapper<any>>;\n  wkrms: Map<string, WKRM>;\n\n  constructor(archesClient: ArchesClient) {\n    this.archesClient = archesClient;\n    this.graphs = new Map<string, ResourceModelWrapper<any>>();\n    this.wkrms = new Map<string, WKRM>();\n  }\n\n  async initialize(configurationOptions: ConfigurationOptions | undefined = undefined) {\n    if (this._initialized) {\n      return;\n    }\n    if (configurationOptions === undefined) {\n      configurationOptions = new ConfigurationOptions();\n    }\n    const graphJsons: GraphResult = await this.archesClient.getGraphs();\n\n    Object.entries(graphJsons[\"models\"]).forEach(([graphId, meta]: [string, StaticGraphMeta]) => {\n      meta.graphid = meta.graphid || graphId;\n      const wkrm = new WKRM(meta);\n      this.wkrms.set(wkrm.modelClassName, wkrm);\n    });\n    let graphs: Array<string> = Object.keys(graphJsons[\"models\"]);\n    const allowedGraphs = configurationOptions.graphs;\n    if (allowedGraphs !== null) {\n      if (allowedGraphs === false) {\n        throw Error(\"No current meaning of allowedGraphs === false\");\n      } else if (allowedGraphs !== true) {\n        graphs = graphs.filter(\n          (graphId: string) => allowedGraphs.includes(graphId),\n        );\n      }\n      await Promise.all(graphs.map(g => this.loadGraph(g)));\n    }\n\n    this._initialized = true;\n  }\n\n  async loadGraph<RIVM extends IRIVM<RIVM>>(modelClass: ResourceInstanceViewModelConstructor<RIVM> | string): Promise<ResourceModelWrapper<RIVM>> {\n    let modelClassName: string;\n    if (typeof modelClass == 'string') {\n      modelClassName = modelClass;\n    } else {\n      modelClassName = modelClass.name;\n    }\n\n    let wkrm = this.wkrms.get(modelClassName);\n    if (wkrm === undefined) {\n      wkrm = [...this.wkrms.values()].find(wkrm => wkrm.graphId === modelClassName);\n      if (wkrm === undefined) {\n        throw Error(`Only loading graphs for which metadata is present, not ${modelClassName}`);\n      }\n      modelClass = wkrm.modelClassName;\n    }\n\n    const wrapper = this.graphs.get(wkrm.graphId);\n    if (wrapper !== undefined) {\n      return wrapper;\n    }\n\n    const bodyJson = await this.archesClient.getGraph(wkrm.meta);\n    if (!bodyJson) {\n      throw Error(`Could not load graph ${wkrm.graphId}`);\n    }\n\n    const graph = new StaticGraph(bodyJson);\n\n    let model: ResourceInstanceViewModelConstructor<RIVM>;\n    if (typeof modelClass == 'string') {\n      modelClassName = modelClass;\n      model = makeResourceModelWrapper<RIVM>(undefined, wkrm, graph);\n    } else {\n      modelClassName = modelClass.name;\n      model = makeResourceModelWrapper<RIVM>(modelClass, wkrm, graph);\n    }\n\n    this.graphs.set(graph.graphid, model.prototype.__);\n    return model.prototype.__;\n  }\n\n  async get<RIVM extends IRIVM<RIVM>>(modelClass: ResourceInstanceViewModelConstructor<RIVM> | string): Promise<ResourceModelWrapper<RIVM>> {\n    let modelClassName: string;\n    if (typeof modelClass == 'string') {\n      modelClassName = modelClass;\n    } else {\n      modelClassName = modelClass.name;\n    }\n\n    // Initialize as a fallback\n    this.initialize(undefined);\n    let wkrm = this.wkrms.get(modelClassName);\n    if (wkrm === undefined) {\n      wkrm = [...this.wkrms.values()].find(w => w.graphId === modelClassName);\n      if (wkrm === undefined) {\n        throw Error(`Cannot find model requested: ${modelClassName}`);\n      }\n    }\n\n    const wrapper = this.graphs.get(wkrm.graphId);\n    if (wrapper === undefined) {\n      return this.loadGraph(modelClass);\n    }\n    return wrapper;\n  }\n\n  async getResource<T extends IRIVM<T>>(resourceId: string, lazy: boolean = true): Promise<T> {\n    const rivm = await staticStore.loadOne(resourceId);\n    let graph = this.graphs.get(rivm.resourceinstance.graph_id);\n    if (!graph) {\n      graph = await this.loadGraph(rivm.resourceinstance.graph_id);\n      if (!graph) {\n        throw Error(`Graph not found for resource ${resourceId}`);\n      }\n    }\n    return graph.fromStaticResource(rivm, lazy);\n  }\n\n  getGraph(graphId: string): StaticGraph {\n    const wrapper = this.graphs.get(graphId);\n    if (wrapper === undefined) {\n      throw Error(`Cannot find graph requested: ${graphId}`);\n    }\n    return wrapper.graph;\n  }\n}\n\nconst graphManager = new GraphManager(archesClient);\nviewContext.graphManager = graphManager;\n\nexport { GraphManager, graphManager, ArchesClientRemote, staticStore, WKRM, ResourceModelWrapper };\n","import { staticStore } from \"./staticStore.ts\"\nimport { PseudoList } from \"./pseudos.ts\"\nimport { UrlViewModel, DateViewModel, ResourceInstanceViewModel, DomainValueViewModel, ConceptValueViewModel, NonLocalizedStringViewModel, StringViewModel, SemanticViewModel, GeoJSONViewModel, BooleanViewModel, NumberViewModel } from './viewModels';\n\nclass Cleanable extends String {\n  __clean: string | undefined\n}\n\nabstract class BaseRenderer {\n  async render(asset: ResourceInstanceViewModel<any>) {\n    if (!asset.$) {\n      throw Error(\"Cannot render unloaded asset - do you want to await asset.retrieve()?\");\n    }\n    const root = await (await asset.$.getRootViewModel());\n    return this.renderValue(root, 0);\n  }\n\n  abstract renderDomainValue(value: DomainValueViewModel, _depth: number): Promise<any>;\n  abstract renderDate(value: DateViewModel, _depth: number): Promise<any>;\n  abstract renderConceptValue(value: ConceptValueViewModel, _depth: number): Promise<any>;\n  abstract renderResourceReference(value: ResourceInstanceViewModel<any>, _depth: number): Promise<any>;\n  abstract renderSemantic(value: SemanticViewModel, depth: number): Promise<any>;\n  abstract renderBlock(block: {[key: string]: string} | {[key: string]: string}[], depth: number): any;\n  abstract renderArray(value: any[], depth: number): Promise<any>;\n  abstract renderString(value: String, _depth: number): Promise<any>;\n  abstract renderBoolean(value: BooleanViewModel, _depth: number): Promise<any>;\n  abstract renderNumber(value: NumberViewModel, _depth: number): Promise<any>;\n  abstract renderUrl(value: UrlViewModel, _depth: number): Promise<any>;\n\n  async renderValue(value: any, depth: number): Promise<any> {\n    let newValue;\n    if (value instanceof Promise) {\n      value = await value;\n    }\n    if (value instanceof DomainValueViewModel) {\n      newValue = this.renderDomainValue(value, depth);\n    } else if (value instanceof DateViewModel) {\n      newValue = this.renderDate(value, depth);\n    } else if (value instanceof ConceptValueViewModel) {\n      newValue = this.renderConceptValue(value, depth);\n    } else if (value instanceof ResourceInstanceViewModel) {\n      newValue = this.renderResourceReference(value, depth);\n    } else if (value instanceof SemanticViewModel) {\n      newValue = this.renderSemantic(value, depth);\n    } else if (value instanceof Array) {\n      newValue = this.renderArray(value, depth);\n    } else if (value instanceof StringViewModel || value instanceof NonLocalizedStringViewModel || typeof value === 'string') {\n      newValue = this.renderString(value, depth);\n    } else if (value instanceof BooleanViewModel) {\n      newValue = this.renderBoolean(value, depth);\n    } else if (value instanceof NumberViewModel) {\n      newValue = this.renderNumber(value, depth);\n    } else if (value instanceof GeoJSONViewModel) {\n      newValue = this.renderBlock(await value.forJson(), depth);\n    } else if (value instanceof UrlViewModel) {\n      newValue = this.renderUrl(await value, depth);\n    } else if (value instanceof Object) {\n      newValue = this.renderBlock(value, depth);\n    } else {\n      newValue = value;\n    }\n    return newValue;\n  }\n}\n\nclass Renderer extends BaseRenderer {\n  async renderDomainValue(value: DomainValueViewModel, _depth: number): Promise<any> {\n    return value;\n  }\n\n  async renderString(value: String, _depth: number): Promise<any> {\n    return `${value}`;\n  }\n\n  async renderNumber(value: Number, _depth: number): Promise<any> {\n    return `${value}`;\n  }\n\n  async renderBoolean(value: Boolean, _depth: number): Promise<any> {\n    return value.toString();\n  }\n\n  async renderDate(value: DateViewModel, _depth: number): Promise<any> {\n    return value;\n  }\n\n  async renderConceptValue(value: ConceptValueViewModel, _depth: number): Promise<any> {\n    return value;\n  }\n\n  async renderResourceReference(value: ResourceInstanceViewModel<any>, _depth: number): Promise<any> {\n    return value;\n  }\n\n  async renderSemantic(value: SemanticViewModel, depth: number): Promise<any> {\n    return this.renderBlock(await value.toObject(), depth);\n  }\n\n  async renderUrl(value: UrlViewModel, _depth: number): Promise<any> {\n    return value;\n  }\n\n  renderBlock(block: {[key: string]: string} | {[key: string]: string}[], depth: number): any {\n    const renderedBlock: {[key: string]: any} = {};\n    const promises: Promise<void>[] = [];\n    for (const [key, value] of Object.entries(block)) {\n      promises.push(\n        this.renderValue(value, depth + 1).then((val: any) => { renderedBlock[key] = val; })\n      );\n    }\n    return Promise.all(promises).then(() => renderedBlock);\n  }\n\n  async renderArray(value: any, depth: number): Promise<any> {\n      return Promise.all(value.map((val: any) => this.renderValue(val, depth + 1)));\n  }\n\n}\n\nclass MarkdownRenderer extends Renderer {\n  conceptValueToUrl: ((value: ConceptValueViewModel) => string) | undefined\n  dateToText: ((value: DateViewModel) => string) | undefined\n  domainValueToUrl: ((value: DomainValueViewModel) => string) | undefined\n  resourceReferenceToUrl: ((value: ResourceInstanceViewModel<any>) => string) | undefined\n  nodeToUrl: ((value: string) => string) | undefined\n\n  constructor(callbacks: {\n    conceptValueToUrl: ((value: ConceptValueViewModel) => string) | undefined,\n    dateToText: ((value: DateViewModel) => string) | undefined,\n    domainValueToUrl: ((value: DomainValueViewModel) => string) | undefined,\n    resourceReferenceToUrl: ((value: ResourceInstanceViewModel<any>) => string) | undefined,\n    nodeToUrl: ((value: string) => string) | undefined,\n  }) {\n    super();\n    this.conceptValueToUrl = callbacks.conceptValueToUrl;\n    this.dateToText = callbacks.dateToText;\n    this.domainValueToUrl = callbacks.domainValueToUrl;\n    this.resourceReferenceToUrl = callbacks.resourceReferenceToUrl;\n    this.nodeToUrl = callbacks.nodeToUrl;\n  }\n\n  async renderUrl(value: UrlViewModel, _depth: number): Promise<any> {\n    const text = `[${value}](${value})`;\n    const wrapper = new Cleanable(text);\n    wrapper.__clean = value.href();\n    console.log(wrapper);\n    return wrapper;\n  }\n\n  override async renderDomainValue(domainValue: DomainValueViewModel, _: number): Promise<any> {\n    const value = await domainValue.getValue();\n    const url = this.domainValueToUrl ? await this.domainValueToUrl(domainValue): null;\n    const text = url ? `[${value.toString()}](${url.trim()})` : value.toString();\n    const wrapper = new Cleanable(`\n    <span\n      class='alizarin-domain-value' data-id='${value.id}'\n    >\n      ${text}\n    </span>`.replace(/\\n/g, ' ').trim());\n    wrapper.__clean = domainValue.toString();\n    return wrapper;\n  }\n\n  override async renderDate(date: DateViewModel, _: number): Promise<any> {\n    const value = await date;\n    const text = this.dateToText ? await this.dateToText(value): value.toISOString();\n    const wrapper = new Cleanable(`\n    <time datetime='${text}'>\n      ${text}\n    </time>`.replace(/\\n/g, ' ').trim());\n    wrapper.__clean = text;\n    return wrapper;\n  }\n\n  override async renderConceptValue(conceptValue: ConceptValueViewModel, _: number): Promise<any> {\n    const value = await conceptValue.getValue();\n    const url = this.conceptValueToUrl ? await this.conceptValueToUrl(conceptValue): null;\n    const text = url ? `[${value.value}](${url.trim()})` : value.value;\n    const wrapper = new Cleanable(`\n    <span\n      class='alizarin-concept-value' data-id='${value.id}'\n      data-concept-id='${value.__concept ? value.__concept.id : \"\"}'\n      data-concept-ref='$${value.__concept ? value.__concept.source : \"\"}'\n    >\n      ${text}\n    </span>`.replace(/\\n/g, ' ').trim());\n    wrapper.__clean = conceptValue.toString();\n    return wrapper;\n  }\n\n  override async renderResourceReference(rivm: ResourceInstanceViewModel<any>, _: number): Promise<any> {\n    const value = await rivm.forJson(false);\n    const url = this.resourceReferenceToUrl ? await this.resourceReferenceToUrl(rivm): null;\n    let title = value.title || value.type || 'Resource';\n    const text = url ? `[${title}](${url.trim()})` : title;\n    const resourceMetadata = await staticStore.getMeta(value.id);\n    if (resourceMetadata) {\n      title = resourceMetadata.name;\n    }\n    const wrapper = new Cleanable(`\n    <span\n      class='alizarin-resource-instance alizarin-related-resource' data-id='${value.id}'\n      data-graph-id='${value.graphId}'\n    >\n      ${text}\n    </span>`.replace(/\\n/g, ' ').trim());\n    wrapper.__clean = rivm.toString();\n    return wrapper;\n  }\n}\n\nclass FlatMarkdownRenderer extends MarkdownRenderer {\n  override async renderSemantic(vm: SemanticViewModel, depth: number): Promise<any> {\n    const children = [...(await vm.__getChildValues()).entries()].map(([_, v]) => [v.node.alias, v.node]);\n    const nodes = Object.fromEntries(await Promise.all(children));\n    return super.renderSemantic(vm, depth).then(async block => {\n      const text = [\n        `* <span class='node-type'>${vm.__node.name}</span> &rarr;`,\n        ...Object.entries(await block).map(([key, value]) => {\n          const node = nodes[key];\n          let nodeName = node.name;\n          if (this.nodeToUrl) {\n            nodeName = `[${node.name}](${this.nodeToUrl(node)})`;\n          }\n          if ((typeof value == 'string' || value instanceof String) && value.indexOf('\\n') != -1) {\n            return `  * <span class='node-name'>${nodeName}</span> <span class='node-alias'>[*${node.alias}*]</span>:<span class='node-value'>\\n${value.split('\\n').map(x => `    ${x}`).join('\\n')}\\n    </span>`;\n          } else {\n            return `  * <span class='node-name'>${nodeName}</span> <span class='node-alias'>[*${node.alias}*]</span>: <span class='node-value'>${value}</span>`;\n          }\n        }).join('\\n').split('\\n')\n      ];\n      if (text[1] == '') {\n        text[0] += `<span class='node-empty'>&lt;empty&gt;</span>`;\n        text.pop();\n      }\n      return text.map(line => `  ${line}`).join('\\n');\n    });\n  }\n\n  override async renderArray(value: any, depth: number): Promise<any> {\n      const rows = await super.renderArray(value, depth);\n      if (value instanceof PseudoList || value.indexOf('\\n') != -1) {\n        return rows.map(x => `${x}`).join('\\n');\n      } else {\n        return rows.join(\", \");\n      }\n  }\n\n  async renderString(value: String, _depth: number): Promise<any> {\n    if (value.indexOf('\\n') != -1) {\n      value = '\\n    ' + value.split('\\n').join('\\n    ');\n    }\n    return value;\n  }\n}\n\nclass JsonRenderer extends Renderer {\n  async renderDate(value: DateViewModel, _depth: number): Promise<any> {\n    return value.forJson();\n  }\n\n  async renderConceptValue(value: ConceptValueViewModel, _depth: number): Promise<any> {\n    return value.forJson();\n  }\n\n  async renderDomainValue(value: DomainValueViewModel, _depth: number): Promise<any> {\n    return value.forJson();\n  }\n\n  async renderResourceReference(value: ResourceInstanceViewModel<any>, _depth: number): Promise<any> {\n    const val = value.forJson();\n    return val;\n  }\n}\n\nexport { MarkdownRenderer, JsonRenderer, Cleanable, FlatMarkdownRenderer };\n","import * as client from \"./client\";\nimport * as interfaces from \"./interfaces\";\nimport { RDM } from \"./rdm\";\nimport { ResourceModelWrapper, WKRM, graphManager, staticStore, GraphManager } from \"./graphManager\";\nimport * as staticTypes from \"./static-types\";\nimport * as utils from \"./utils\";\nimport * as viewModels from \"./viewModels\";\nimport * as renderers from \"./renderers\";\nimport * as nodeConfig from \"./nodeConfig\";\n\nconst AlizarinModel = viewModels.ResourceInstanceViewModel;\nexport {\n  AlizarinModel,\n  client,\n  graphManager,\n  GraphManager,\n  staticTypes,\n  utils,\n  viewModels,\n  staticStore,\n  RDM,\n  renderers,\n  interfaces,\n  WKRM,\n  nodeConfig,\n  ResourceModelWrapper\n};\n","export default {}"],"names":["DEFAULT_LANGUAGE","response","archesClient","resource","nodeConfig","node","promise","value","val","ids","collection","str","tile","_a","vm","nodegroupId","newImpliedNodegroups","edges","wkrm","viewModels.ResourceInstanceViewModel"],"mappings":"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"}